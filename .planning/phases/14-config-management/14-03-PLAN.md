# Phase 14 Plan 03: File Watching + External Change Detection

## Wave
Wave 2 (depends on Plan 01 and Plan 02 — needs the sidebar and config store enhancements in place)

## Objective
Implement file watching for config files so the UI detects external changes (e.g., user editing `hooks.yaml` in another editor). Auto-reload unmodified files silently; prompt the user with a conflict dialog for files with unsaved changes. Addresses SC-5 (auto-reload on external file changes, debounced).

## Why This Plan Exists
Config files are commonly edited outside the RuleZ UI — in VS Code, vim, or by the `rulez init` command. Without file watching, users must close and reopen files to see external changes. This plan adds real-time awareness of external modifications.

## Tasks

### Task 1: Create file watcher utility
**File(s):**
- `rulez_ui/src/lib/file-watcher.ts` (NEW)

**Action:**
1. Create a `ConfigFileWatcher` class (or hook `useConfigFileWatcher`) that:
   - Accepts a list of file paths to watch
   - Uses Tauri's `watchImmediate()` from `@tauri-apps/plugin-fs` in Tauri mode
   - In browser mode: no-op (mock files don't change externally)
   - Debounces events by 500ms to handle editors that do save-to-temp-then-rename
   - Emits a callback `onFileChanged(path: string)` when a watched file is modified

2. API:
   ```typescript
   interface FileWatcherOptions {
     paths: string[];
     onFileChanged: (path: string) => void;
     debounceMs?: number; // default: 500
   }

   export function createFileWatcher(options: FileWatcherOptions): {
     start: () => Promise<void>;
     stop: () => void;
     updatePaths: (paths: string[]) => Promise<void>;
   };
   ```

3. The watcher should:
   - Only watch existing files (skip non-existent paths gracefully)
   - Clean up watchers on `stop()`
   - Handle `updatePaths()` by stopping old watchers and starting new ones

**Acceptance:**
- Watcher starts/stops cleanly
- Debounces rapid events
- No-ops in browser mode
- `tsc --noEmit` passes

### Task 2: Create ExternalChangeDialog component
**File(s):**
- `rulez_ui/src/components/config/ExternalChangeDialog.tsx` (NEW)

**Action:**
1. Create a dialog that appears when an externally-changed file has unsaved changes in the editor:
   - Title: "File Changed on Disk"
   - Message: "The file `{filename}` has been modified outside RuleZ UI. You have unsaved changes."
   - Two buttons:
     - "Reload" — discards editor changes, reloads from disk
     - "Keep Mine" — ignores the external change, keeps editor content
2. Props:
   ```typescript
   interface ExternalChangeDialogProps {
     filePath: string;
     onReload: () => void;
     onKeepMine: () => void;
   }
   ```
3. Style consistently with the existing `ConfirmDialog` in `FileTabBar.tsx`

**Acceptance:**
- Dialog shows file name and clear action buttons
- Reload and Keep Mine callbacks work correctly
- Accessible (keyboard navigable, aria labels)
- `tsc --noEmit` passes

### Task 3: Integrate file watcher into AppShell
**File(s):**
- `rulez_ui/src/components/layout/AppShell.tsx` (MODIFY)
- `rulez_ui/src/stores/configStore.ts` (MODIFY)

**Action:**
1. In `AppShell.tsx` (or a new `useFileWatcher` hook used by AppShell):
   - After config files are loaded, start watching their paths
   - On file change callback:
     - If the file is open in configStore and `modified === false`: auto-reload silently
       - Call `readConfig(path)` to get new content
       - Call `configStore.openFile(path, newContent)` (which updates content and originalContent)
     - If the file is open and `modified === true`: show `ExternalChangeDialog`
       - On "Reload": read new content, update store, close dialog
       - On "Keep Mine": dismiss dialog, do nothing
     - If the file is NOT open: just update the sidebar file list (call `listConfigFiles()` to refresh)
   - Clean up watcher on component unmount

2. Add `reloadFile(path: string, content: string)` action to configStore:
   - Updates both `content` and `originalContent` to the new content
   - Sets `modified = false`
   - This avoids the "modified" flag being set by the reload

3. Collect watched paths from `configStore.globalConfig` and `configStore.projectConfig`

**Acceptance:**
- External file changes are detected within ~1 second (500ms debounce + processing)
- Unmodified open files auto-reload silently
- Modified open files show conflict dialog
- Watcher cleans up on unmount
- `tsc --noEmit` and `npm run build` pass

## Verification
1. `cd rulez_ui && npx tsc --noEmit` — passes
2. `npx biome check src/lib/file-watcher.ts src/components/config/ src/components/layout/AppShell.tsx src/stores/configStore.ts` — no errors
3. `npm run build` — succeeds
4. Visual: In browser dev mode, components render without error (watcher no-ops but doesn't crash)
5. Full Phase 14 manual test: open app → verify scope badges → import a config → export a config → (if Tauri) edit file externally → verify reload prompt

## Dependencies
- **Plan 01 must be complete**: configStore enhancements (getScopeInfo)
- **Plan 02 must be complete**: Import/export flows, `readConfig` patterns
- `@tauri-apps/plugin-fs` `watchImmediate()` API (already installed)
