---
phase: 07-json-schema-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - rulez/Cargo.toml
  - rulez/src/schema.rs
  - rulez/src/models.rs
  - rulez/src/main.rs
autonomous: true

must_haves:
  truths:
    - "Malformed event JSON (not valid JSON) returns exit code 1 with clear error message"
    - "Schema validation is fail-open: events with unexpected fields or schema deviations that do not prevent serde deserialization log a warning and continue processing"
    - "Serde deserialization errors for required fields (e.g., missing hook_event_name) are fatal and return a non-zero exit code -- this is NOT fail-open"
    - "Valid event JSON passes schema validation with no overhead perceptible to the user"
    - "Schema is auto-generated from the Event Rust struct, not maintained manually"
    - "Schema draft version is 2020-12 (generated by schemars 1.2) and is queryable via schema_draft_version()"
  artifacts:
    - path: "rulez/src/schema.rs"
      provides: "Schema generation, validation module, and draft version query"
      contains: "validate_event_schema"
    - path: "rulez/src/models.rs"
      provides: "JsonSchema derive on Event and EventType"
      contains: "JsonSchema"
    - path: "rulez/Cargo.toml"
      provides: "schemars and jsonschema dependencies"
      contains: "schemars"
  key_links:
    - from: "rulez/src/main.rs"
      to: "rulez/src/schema.rs"
      via: "validate_event_schema() called in process_hook_event()"
      pattern: "schema::validate_event_schema"
    - from: "rulez/src/schema.rs"
      to: "rulez/src/models.rs"
      via: "schema_for!(Event) to generate schema from struct"
      pattern: "schema_for.*Event"
---

<objective>
Add JSON Schema validation for incoming hook events by deriving `JsonSchema` on the Event struct, generating the schema at compile time, pre-compiling a validator at startup via `LazyLock`, and integrating schema validation into the hook event processing pipeline.

Purpose: Catch malformed payloads before rule processing with clear error messages. Schema validation is fail-open (warns on schema deviations, continues processing). Serde deserialization of required fields remains fail-closed (fatal error if Event struct cannot be constructed).

Output: Working schema validation module (`schema.rs`), updated Event types with `JsonSchema` derive, draft version query function, and integration into `process_hook_event()` in `main.rs`.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@rulez/src/main.rs
@rulez/src/models.rs
@rulez/src/config.rs
@rulez/Cargo.toml
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and derive JsonSchema on Event types, create schema module</name>
  <files>
    Cargo.toml
    rulez/Cargo.toml
    rulez/src/schema.rs
    rulez/src/models.rs
  </files>
  <action>
**Step 1: Add dependencies to workspace Cargo.toml:**

Add to `[workspace.dependencies]` section:
```toml
schemars = { version = "1.2", features = ["derive"] }
jsonschema = "0.28"
```

Note: Use jsonschema 0.28 (not 0.41 as research suggested -- 0.41 does not exist for the Rust crate). The modern Rust jsonschema API uses `jsonschema::validator_for(&schema)` which returns a `Validator` that has `is_valid()`, `validate()`, and `iter_errors()` methods.

**Step 2: Add dependencies to rulez/Cargo.toml:**

Add under `[dependencies]`:
```toml
schemars.workspace = true
jsonschema.workspace = true
```

**Step 3: Derive `JsonSchema` on Event and EventType in models.rs:**

Only derive `JsonSchema` on the types needed for Event schema generation. These are the types directly referenced by Event struct fields:
- `EventType` enum (line ~2318): Add `JsonSchema` to the derive list. EventType already has `Serialize, Deserialize` so schemars will read the serde attributes.
- `Event` struct (line ~2268): Add `JsonSchema` to the derive list.

Add `use schemars::JsonSchema;` at the top of models.rs.

**Important:** Do NOT derive `JsonSchema` on every type in models.rs -- only `Event` and `EventType`. The other fields of Event are standard types (`String`, `Option<String>`, `serde_json::Value`, `DateTime<Utc>`) which schemars already supports. For `DateTime<Utc>`, schemars has built-in support for chrono types when chrono feature is enabled -- but since schemars 1.2 supports chrono out of the box, this should work. If chrono types cause issues, use `#[schemars(with = "String")]` on the timestamp field as a fallback.

**Step 4: Create rulez/src/schema.rs module:**

```rust
//! JSON Schema validation for incoming hook events.
//!
//! Validates event JSON against an auto-generated schema derived from the
//! Event struct. Uses fail-open semantics for schema validation: structurally
//! unexpected events log warnings but continue processing.
//!
//! **Important distinction (REQ-SCHEMA-04):**
//! - Schema validation is fail-open: extra fields, wrong optional types, etc.
//!   produce warnings but do NOT block processing.
//! - Serde deserialization is fail-closed: if the JSON cannot be deserialized
//!   into an Event struct (missing required fields like hook_event_name or
//!   session_id), that is a fatal error handled by the caller.

use schemars::schema_for;
use std::sync::LazyLock;
use tracing::warn;

use crate::models::Event;

/// Pre-compiled JSON Schema validator for Event structs.
/// Generated from the Event type's JsonSchema derive at startup.
/// Uses LazyLock for thread-safe, one-time initialization.
static EVENT_VALIDATOR: LazyLock<jsonschema::Validator> = LazyLock::new(|| {
    let schema = schema_for!(Event);
    let schema_value =
        serde_json::to_value(&schema).expect("Failed to serialize Event schema");
    jsonschema::validator_for(&schema_value)
        .expect("Failed to compile Event schema validator")
});

/// Validate an event JSON value against the Event schema.
///
/// **Fail-open semantics (REQ-SCHEMA-04):**
/// - If the event JSON has schema deviations (extra fields, wrong types in
///   optional fields, missing optional fields), this function logs a warning
///   and returns so processing continues.
/// - This function does NOT handle malformed JSON (not valid JSON at all) --
///   that is caught earlier by serde_json::from_str() in process_hook_event().
/// - This function does NOT handle serde deserialization failures (missing
///   required fields) -- that is caught later by serde_json::from_value()
///   in process_hook_event() and IS fatal.
///
/// Returns () always (fail-open). Validation errors are logged as warnings.
pub fn validate_event_schema(event_json: &serde_json::Value) {
    if !EVENT_VALIDATOR.is_valid(event_json) {
        let errors: Vec<String> = EVENT_VALIDATOR
            .iter_errors(event_json)
            .map(|e| format!("{} at {}", e, e.instance_path))
            .collect();
        warn!(
            "Event schema validation warning (fail-open): {}",
            errors.join("; ")
        );
    }
}

/// Generate the Event JSON Schema as a serde_json::Value.
///
/// Useful for schema export (`rulez schema --export`) and testing.
#[allow(dead_code)]
pub fn generate_event_schema() -> serde_json::Value {
    let schema = schema_for!(Event);
    serde_json::to_value(&schema).expect("Failed to serialize Event schema")
}

/// Return the JSON Schema draft version used by the auto-generated schema.
///
/// schemars 1.2 generates JSON Schema 2020-12 (REQ-SCHEMA-06).
/// Since the schema is auto-generated (not user-provided), the draft version
/// is fixed by the schemars library version.
#[allow(dead_code)]
pub fn schema_draft_version() -> &'static str {
    "https://json-schema.org/draft/2020-12/schema"
}
```

Key design decisions:
- `validate_event_schema()` returns `()` not `Result<()>` because it's fail-open. It never errors.
- The validator is pre-compiled via `LazyLock` (REQ-SCHEMA-03) for <0.1ms validation time.
- Schema is auto-generated from the Event struct (REQ-SCHEMA-02), not a manual JSON file.
- Warning is logged to tracing (which feeds into the audit trail) per REQ-SCHEMA-04.
- `schema_draft_version()` returns the 2020-12 draft URI (REQ-SCHEMA-06). Since schemars auto-generates the schema, the draft is fixed by library version, not user input.
  </action>
  <verify>
Run `cargo check --workspace` to verify compilation succeeds with new dependencies and derives.
Run `cargo clippy --all-targets --all-features --workspace -- -D warnings` to verify no warnings.
  </verify>
  <done>
- schemars and jsonschema are in workspace and rulez Cargo.toml
- Event and EventType have JsonSchema derive
- schema.rs module exists with validate_event_schema(), generate_event_schema(), and schema_draft_version()
- Pre-compiled validator uses LazyLock
- schema_draft_version() returns the 2020-12 draft URI (REQ-SCHEMA-06)
- Code compiles and passes clippy
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate schema validation into process_hook_event pipeline</name>
  <files>
    rulez/src/main.rs
  </files>
  <action>
**Step 1: Add schema module declaration in main.rs:**

Add `mod schema;` alongside the other module declarations (after `mod models;`).

**Step 2: Modify process_hook_event() to validate schema:**

The current flow is:
1. Read stdin to buffer
2. Check if empty -> exit 1
3. `serde_json::from_str::<Event>(&buffer)` -> parse and deserialize in one step
4. Process event

The new flow should be:
1. Read stdin to buffer
2. Check if empty -> exit 1
3. `serde_json::from_str::<serde_json::Value>(&buffer)` -> parse as raw JSON Value first (REQ-SCHEMA-05: exit code 1 for malformed JSON)
4. `schema::validate_event_schema(&event_value)` -> fail-open schema validation (logs warning, never blocks)
5. `serde_json::from_value::<Event>(event_value)` -> deserialize to Event struct (fail-closed: missing required fields = fatal error)
6. Process event as before

**Critical clarification on fail-open vs fail-closed (REQ-SCHEMA-04):**
- Step 4 (schema validation) is FAIL-OPEN: warns but never blocks
- Step 5 (serde deserialization) is FAIL-CLOSED: if hook_event_name or session_id are missing, Event cannot be constructed, and this is a fatal error (the `?` operator propagates the error, resulting in a non-zero exit)
- This is NOT a contradiction: REQ-SCHEMA-04 says "log warnings on invalid events but continue processing" which applies to schema-level validation. Serde deserialization failures mean the event literally cannot be represented as an Event struct, so there is nothing to "continue processing" with.

Replace the current `process_hook_event` function body:

```rust
async fn process_hook_event(cli: &Cli, _config: &config::Config) -> Result<()> {
    let mut buffer = String::new();
    io::stdin().read_to_string(&mut buffer)?;

    if buffer.trim().is_empty() {
        error!("No input received on stdin");
        std::process::exit(1);
    }

    // Step 1: Parse as raw JSON Value first (REQ-SCHEMA-05)
    // Malformed JSON (syntax errors) -> exit code 1 (config error)
    let event_value: serde_json::Value = serde_json::from_str(&buffer).map_err(|e| {
        error!("Failed to parse hook event JSON: {}", e);
        std::process::exit(1);
    })?;

    // Step 2: Validate against Event schema (REQ-SCHEMA-04: fail-open)
    // Schema deviations (extra fields, wrong optional types) log a warning
    // but continue processing. This does NOT catch missing required fields --
    // that is handled by serde deserialization below.
    schema::validate_event_schema(&event_value);

    // Step 3: Deserialize to strongly-typed Event struct (fail-closed)
    // Missing required fields (hook_event_name, session_id) are fatal because
    // the Event struct cannot be constructed without them. This is intentional:
    // fail-open applies to schema validation, not to type construction.
    let event: models::Event = serde_json::from_value(event_value).map_err(|e| {
        error!("Failed to deserialize hook event: {}", e);
        e
    })?;

    info!(
        "Processing event: {} ({})",
        event.hook_event_name, event.session_id
    );

    // Reload config using the event's cwd so we read the correct project's hooks.yaml
    let project_config =
        config::Config::load(event.cwd.as_ref().map(|p| std::path::Path::new(p.as_str())))?;
    let debug_config = models::DebugConfig::new(cli.debug_logs, project_config.settings.debug_logs);
    let response = hooks::process_event(event, &debug_config).await?;

    if !response.continue_ {
        let reason = response
            .reason
            .as_deref()
            .unwrap_or("Blocked by RuleZ policy");
        eprintln!("{}", reason);
        std::process::exit(2);
    }

    // For allowed responses (with or without context injection), output JSON to stdout
    let json = serde_json::to_string(&response)?;
    println!("{}", json);

    Ok(())
}
```

**Important notes:**
- The `serde_json::from_str` for raw Value parsing uses `std::process::exit(1)` on failure (REQ-SCHEMA-05), not returning an error that could be caught. This is intentional -- malformed JSON is a config-level error.
- The `serde_json::from_value` for Event deserialization propagates the error via `?`. When `main()` returns an `Err`, the process exits with code 1 (anyhow default). This is correct: missing required fields is a data error, not a policy block (exit 2).
- The schema validation call is between JSON parsing and Event deserialization. This is the correct position because schema validation operates on the raw JSON Value.
  </action>
  <verify>
Run `cargo build --workspace` to verify compilation.
Run `cargo test --tests --all-features --workspace` to verify existing tests still pass.
Run `echo '{"invalid json' | cargo run -q 2>&1; echo "Exit: $?"` to verify malformed JSON exits with code 1.
Run `echo '{}' | cargo run -q 2>&1; echo "Exit: $?"` to verify schema validation warns (fail-open) and then serde deserialization fails (fail-closed) with non-zero exit.
Run `echo '{"hook_event_name":"PreToolUse","session_id":"test"}' | cargo run -q 2>&1; echo "Exit: $?"` to verify valid minimal event processes.
  </verify>
  <done>
- schema module is declared in main.rs
- process_hook_event() validates JSON schema before Event deserialization
- Malformed JSON (syntax errors) produces exit code 1
- Schema validation is fail-open (logs warning, continues)
- Serde deserialization of required fields is fail-closed (fatal error if Event cannot be constructed)
- All existing tests pass
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` compiles cleanly
2. `cargo clippy --all-targets --all-features --workspace -- -D warnings` passes
3. `cargo test --tests --all-features --workspace` passes (all existing tests)
4. `echo '{"invalid' | cargo run -q 2>&1; echo $?` returns exit code 1
5. `echo '{"hook_event_name":"PreToolUse","session_id":"test123"}' | cargo run -q 2>&1` processes without schema warnings
6. `echo '{}' | cargo run -q 2>&1; echo $?` shows schema warning (fail-open) then deserialization error (non-zero exit)
</verification>

<success_criteria>
- schemars and jsonschema dependencies added to workspace
- Event and EventType have JsonSchema derive
- schema.rs module with pre-compiled LazyLock validator and schema_draft_version()
- process_hook_event() validates schema before processing
- Fail-open: schema deviations log warning, continue to deserialization
- Fail-closed: serde deserialization errors for required fields are fatal
- Fail-fast: malformed JSON exits with code 1
- schema_draft_version() returns 2020-12 URI (REQ-SCHEMA-06)
- All 605+ existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-json-schema-validation/07-01-SUMMARY.md`
</output>
