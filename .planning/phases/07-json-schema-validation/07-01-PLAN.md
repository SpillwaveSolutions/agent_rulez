---
phase: 07-json-schema-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - rulez/Cargo.toml
  - rulez/src/schema.rs
  - rulez/src/models.rs
  - rulez/src/main.rs
autonomous: true

must_haves:
  truths:
    - "Malformed event JSON (not valid JSON) returns exit code 1 with clear error message"
    - "Structurally invalid event JSON (valid JSON but wrong shape) logs warning and continues processing (fail-open)"
    - "Valid event JSON passes schema validation with no overhead perceptible to the user"
    - "Schema is auto-generated from the Event Rust struct, not maintained manually"
  artifacts:
    - path: "rulez/src/schema.rs"
      provides: "Schema generation and validation module"
      contains: "validate_event_schema"
    - path: "rulez/src/models.rs"
      provides: "JsonSchema derive on Event and EventType"
      contains: "JsonSchema"
    - path: "rulez/Cargo.toml"
      provides: "schemars and jsonschema dependencies"
      contains: "schemars"
  key_links:
    - from: "rulez/src/main.rs"
      to: "rulez/src/schema.rs"
      via: "validate_event_schema() called in process_hook_event()"
      pattern: "schema::validate_event_schema"
    - from: "rulez/src/schema.rs"
      to: "rulez/src/models.rs"
      via: "schema_for!(Event) to generate schema from struct"
      pattern: "schema_for.*Event"
---

<objective>
Add JSON Schema validation for incoming hook events by deriving `JsonSchema` on the Event struct, generating the schema at compile time, pre-compiling a validator at startup via `LazyLock`, and integrating fail-open validation into the hook event processing pipeline.

Purpose: Catch malformed payloads before rule processing with clear error messages, while ensuring structurally invalid events are logged but not blocked (fail-open mode per REQ-SCHEMA-04).

Output: Working schema validation module (`schema.rs`), updated Event types with `JsonSchema` derive, and integration into `process_hook_event()` in `main.rs`.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@rulez/src/main.rs
@rulez/src/models.rs
@rulez/src/config.rs
@rulez/Cargo.toml
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and derive JsonSchema on Event types, create schema module</name>
  <files>
    Cargo.toml
    rulez/Cargo.toml
    rulez/src/schema.rs
    rulez/src/models.rs
  </files>
  <action>
**Step 1: Add dependencies to workspace Cargo.toml:**

Add to `[workspace.dependencies]` section:
```toml
schemars = { version = "1.2", features = ["derive"] }
jsonschema = "0.28"
```

Note: Use jsonschema 0.28 (not 0.41 as research suggested -- 0.41 does not exist for the Rust crate). The modern Rust jsonschema API uses `jsonschema::validator_for(&schema)` which returns a `Validator` that has `is_valid()`, `validate()`, and `iter_errors()` methods.

**Step 2: Add dependencies to rulez/Cargo.toml:**

Add under `[dependencies]`:
```toml
schemars.workspace = true
jsonschema.workspace = true
```

**Step 3: Derive `JsonSchema` on Event and EventType in models.rs:**

Only derive `JsonSchema` on the types needed for Event schema generation. These are the types directly referenced by Event struct fields:
- `EventType` enum (line ~2314): Add `JsonSchema` to the derive list. EventType already has `Serialize, Deserialize` so schemars will read the serde attributes.
- `Event` struct (line ~2268): Add `JsonSchema` to the derive list.

Add `use schemars::JsonSchema;` at the top of models.rs.

**Important:** Do NOT derive `JsonSchema` on every type in models.rs -- only `Event` and `EventType`. The other fields of Event are standard types (`String`, `Option<String>`, `serde_json::Value`, `DateTime<Utc>`) which schemars already supports. For `DateTime<Utc>`, schemars has built-in support for chrono types when chrono feature is enabled -- but since schemars 1.2 supports chrono out of the box, this should work. If chrono types cause issues, use `#[schemars(with = "String")]` on the timestamp field as a fallback.

**Step 4: Create rulez/src/schema.rs module:**

```rust
//! JSON Schema validation for incoming hook events.
//!
//! Validates event JSON against an auto-generated schema derived from the
//! Event struct. Uses fail-open semantics: structurally invalid events
//! log warnings but continue processing.

use schemars::schema_for;
use std::sync::LazyLock;
use tracing::warn;

use crate::models::Event;

/// Pre-compiled JSON Schema validator for Event structs.
/// Generated from the Event type's JsonSchema derive at startup.
/// Uses LazyLock for thread-safe, one-time initialization.
static EVENT_VALIDATOR: LazyLock<jsonschema::Validator> = LazyLock::new(|| {
    let schema = schema_for!(Event);
    let schema_value =
        serde_json::to_value(&schema).expect("Failed to serialize Event schema");
    jsonschema::validator_for(&schema_value)
        .expect("Failed to compile Event schema validator")
});

/// Validate an event JSON value against the Event schema.
///
/// **Fail-open semantics (REQ-SCHEMA-04):**
/// - If the event JSON is structurally invalid (valid JSON but doesn't match
///   schema), this function logs a warning and returns Ok(()) so processing
///   continues.
/// - This function does NOT handle malformed JSON (not valid JSON at all) --
///   that is caught earlier by serde_json::from_str() in process_hook_event().
///
/// Returns Ok(()) always (fail-open). Validation errors are logged as warnings.
pub fn validate_event_schema(event_json: &serde_json::Value) {
    if !EVENT_VALIDATOR.is_valid(event_json) {
        let errors: Vec<String> = EVENT_VALIDATOR
            .iter_errors(event_json)
            .map(|e| format!("{} at {}", e, e.instance_path))
            .collect();
        warn!(
            "Event schema validation warning (fail-open): {}",
            errors.join("; ")
        );
    }
}

/// Generate the Event JSON Schema as a serde_json::Value.
///
/// Useful for schema export (`rulez schema --export`) and testing.
#[allow(dead_code)]
pub fn generate_event_schema() -> serde_json::Value {
    let schema = schema_for!(Event);
    serde_json::to_value(&schema).expect("Failed to serialize Event schema")
}
```

Key design decisions:
- `validate_event_schema()` returns `()` not `Result<()>` because it's fail-open. It never errors.
- The validator is pre-compiled via `LazyLock` (REQ-SCHEMA-03) for <0.1ms validation time.
- Schema is auto-generated from the Event struct (REQ-SCHEMA-02), not a manual JSON file.
- Warning is logged to tracing (which feeds into the audit trail) per REQ-SCHEMA-04.
  </action>
  <verify>
Run `cargo check --workspace` to verify compilation succeeds with new dependencies and derives.
Run `cargo clippy --all-targets --all-features --workspace -- -D warnings` to verify no warnings.
  </verify>
  <done>
- schemars and jsonschema are in workspace and rulez Cargo.toml
- Event and EventType have JsonSchema derive
- schema.rs module exists with validate_event_schema() and generate_event_schema()
- Pre-compiled validator uses LazyLock
- Code compiles and passes clippy
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate schema validation into process_hook_event pipeline</name>
  <files>
    rulez/src/main.rs
  </files>
  <action>
**Step 1: Add schema module declaration in main.rs:**

Add `mod schema;` alongside the other module declarations (after `mod models;`).

**Step 2: Modify process_hook_event() to validate schema:**

The current flow is:
1. Read stdin to buffer
2. Check if empty -> exit 1
3. `serde_json::from_str::<Event>(&buffer)` -> parse and deserialize in one step
4. Process event

The new flow should be:
1. Read stdin to buffer
2. Check if empty -> exit 1
3. `serde_json::from_str::<serde_json::Value>(&buffer)` -> parse as raw JSON Value first (REQ-SCHEMA-05: exit code 1 for malformed JSON, not exit code 2)
4. `schema::validate_event_schema(&event_value)` -> fail-open schema validation (logs warning, never blocks)
5. `serde_json::from_value::<Event>(event_value)` -> deserialize to Event struct
6. Process event as before

Replace the current `process_hook_event` function body. The key changes:

```rust
async fn process_hook_event(cli: &Cli, _config: &config::Config) -> Result<()> {
    let mut buffer = String::new();
    io::stdin().read_to_string(&mut buffer)?;

    if buffer.trim().is_empty() {
        error!("No input received on stdin");
        std::process::exit(1);
    }

    // Step 1: Parse as raw JSON Value first (REQ-SCHEMA-05)
    // Malformed JSON (syntax errors) -> exit code 1 (config error)
    let event_value: serde_json::Value = serde_json::from_str(&buffer).map_err(|e| {
        error!("Failed to parse hook event JSON: {}", e);
        std::process::exit(1);
    })?;

    // Step 2: Validate against Event schema (REQ-SCHEMA-04: fail-open)
    // Structurally invalid events log a warning but continue processing
    schema::validate_event_schema(&event_value);

    // Step 3: Deserialize to strongly-typed Event struct
    let event: models::Event = serde_json::from_value(event_value).map_err(|e| {
        error!("Failed to deserialize hook event: {}", e);
        e
    })?;

    info!(
        "Processing event: {} ({})",
        event.hook_event_name, event.session_id
    );

    // Reload config using the event's cwd so we read the correct project's hooks.yaml
    let project_config =
        config::Config::load(event.cwd.as_ref().map(|p| std::path::Path::new(p.as_str())))?;
    let debug_config = models::DebugConfig::new(cli.debug_logs, project_config.settings.debug_logs);
    let response = hooks::process_event(event, &debug_config).await?;

    if !response.continue_ {
        let reason = response
            .reason
            .as_deref()
            .unwrap_or("Blocked by RuleZ policy");
        eprintln!("{}", reason);
        std::process::exit(2);
    }

    // For allowed responses (with or without context injection), output JSON to stdout
    let json = serde_json::to_string(&response)?;
    println!("{}", json);

    Ok(())
}
```

**Important notes:**
- The `serde_json::from_str` for raw Value parsing uses `std::process::exit(1)` on failure (REQ-SCHEMA-05), not returning an error that could be caught. This is intentional -- malformed JSON is a config-level error.
- The `serde_json::from_value` for Event deserialization still returns an error normally -- if the JSON is valid but can't deserialize to Event after passing schema validation, this is an unexpected case that should propagate.
- The schema validation call is between JSON parsing and Event deserialization. This is the correct position because schema validation operates on the raw JSON Value.
  </action>
  <verify>
Run `cargo build --workspace` to verify compilation.
Run `cargo test --tests --all-features --workspace` to verify existing tests still pass.
Run `echo '{"invalid json' | cargo run -q 2>&1; echo "Exit: $?"` to verify malformed JSON exits with code 1.
Run `echo '{}' | cargo run -q 2>&1; echo "Exit: $?"` to verify structurally invalid JSON (empty object) still attempts processing (fail-open).
  </verify>
  <done>
- schema module is declared in main.rs
- process_hook_event() validates JSON schema before Event deserialization
- Malformed JSON (syntax errors) produces exit code 1
- Structurally invalid JSON logs warning but continues (fail-open)
- All existing tests pass
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` compiles cleanly
2. `cargo clippy --all-targets --all-features --workspace -- -D warnings` passes
3. `cargo test --tests --all-features --workspace` passes (all existing tests)
4. `echo '{"invalid' | cargo run -q 2>&1; echo $?` returns exit code 1
5. `echo '{"hook_event_name":"PreToolUse","session_id":"test123"}' | cargo run -q 2>&1` processes without schema warnings
</verification>

<success_criteria>
- schemars and jsonschema dependencies added to workspace
- Event and EventType have JsonSchema derive
- schema.rs module with pre-compiled LazyLock validator
- process_hook_event() validates schema before processing
- Fail-open: invalid structure logs warning, continues
- Fail-fast: malformed JSON exits with code 1
- All 605+ existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-json-schema-validation/07-01-SUMMARY.md`
</output>
