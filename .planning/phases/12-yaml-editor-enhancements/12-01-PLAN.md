# Phase 12 Plan 01: Schema Hardening + YAML Formatting Provider

## Wave
Wave 1 (can execute in parallel with Plan 02)

## Objective
Fix schema autocomplete to work reliably in both Vite dev and Tauri production by inlining the schema, and register a comment-preserving YAML formatting provider so the Format button and Ctrl+Shift+I actually work.

## Why This Plan Exists
Satisfies success criteria:
1. **User gets schema-driven autocomplete suggestions when typing rule field names** (EDIT-01)
2. **User sees inline error markers (red squiggles) for YAML syntax violations and schema mismatches** (EDIT-02)
4. **User can format/indent YAML via keyboard shortcut** (EDIT-04, partial — format-on-save wired in Plan 03)

## Tasks

### Task 1: Inline the JSON Schema in configureYamlSchema
**File(s):**
- `rulez_ui/src/lib/schema.ts`

**Action:**
The current `configureYamlSchema` uses `enableSchemaRequest: true` with a relative URL (`/schema/hooks-schema.json`). This relies on Vite's dev server to serve the file and will break in Tauri production builds where assets use `tauri://localhost/`.

Fix by:
1. Import the schema JSON directly using Vite's JSON import: `import hooksSchema from "@/../public/schema/hooks-schema.json";`
2. Pass the schema object inline via the `schema` property instead of relying on HTTP fetch.
3. Set `enableSchemaRequest: false` (no longer needed).
4. Use the schema's `$id` (`https://spillwave.dev/schemas/hooks-config/v1.0`) as the `uri` value (this is a logical identifier, not fetched).
5. Change the function return type to `IDisposable` so callers can track the disposable — `configureMonacoYaml` returns one.
6. Update the type import to include `IDisposable` from `monaco-editor`.

Result should look like:
```typescript
import { configureMonacoYaml } from "monaco-yaml";
import type { IDisposable } from "monaco-editor";
import hooksSchema from "@/../public/schema/hooks-schema.json";

type MonacoInstance = Parameters<typeof configureMonacoYaml>[0];

export function configureYamlSchema(monaco: MonacoInstance): IDisposable {
  return configureMonacoYaml(monaco, {
    enableSchemaRequest: false,
    schemas: [
      {
        uri: "https://spillwave.dev/schemas/hooks-config/v1.0",
        fileMatch: ["*"],
        schema: hooksSchema as Record<string, unknown>,
      },
    ],
  });
}
```

**Acceptance:**
- `cd rulez_ui && npx tsc --noEmit` passes (no type errors)
- The import resolves (Vite handles JSON imports natively)
- `enableSchemaRequest` is `false`, schema is inline

### Task 2: Register a comment-preserving YAML DocumentFormattingEditProvider
**File(s):**
- `rulez_ui/src/lib/yaml-formatter.ts` (NEW)
- `rulez_ui/src/components/editor/YamlEditor.tsx`

**Action:**

**Create `rulez_ui/src/lib/yaml-formatter.ts`:**
Register a `DocumentFormattingEditProvider` for the `"yaml"` language using the `yaml` package's `parseDocument` + `doc.toString()` (NOT `parse` + `stringify` which drops comments).

The provider must:
1. Call `parseDocument(content)` to get the YAML AST (preserves comments)
2. Check `doc.errors.length > 0` — if there are parse errors, return empty edits (don't format broken YAML)
3. Call `doc.toString({ indent: options.tabSize, lineWidth: 0 })` to format. `lineWidth: 0` disables line wrapping.
4. Compare formatted output to current content — if identical, return empty edits (avoid no-op flicker)
5. Return a single `TextEdit` replacing the full model range with the formatted text
6. Wrap everything in try/catch, returning `[]` on error (silent failure is better than crashing the editor)
7. Export a function `registerYamlFormatter(monaco): IDisposable` that returns the disposable from `monaco.languages.registerDocumentFormattingEditProvider`

```typescript
import { parseDocument } from "yaml";
import type { IDisposable, editor, languages } from "monaco-editor";

export function registerYamlFormatter(
  monaco: typeof import("monaco-editor"),
): IDisposable {
  return monaco.languages.registerDocumentFormattingEditProvider("yaml", {
    provideDocumentFormattingEdits(
      model: editor.ITextModel,
      options: languages.FormattingOptions,
    ): languages.TextEdit[] {
      try {
        const content = model.getValue();
        const doc = parseDocument(content);
        if (doc.errors.length > 0) return [];
        const formatted = doc.toString({
          indent: options.tabSize,
          lineWidth: 0,
        });
        if (formatted === content) return [];
        return [{ range: model.getFullModelRange(), text: formatted }];
      } catch {
        return [];
      }
    },
  });
}
```

**Update `rulez_ui/src/components/editor/YamlEditor.tsx`:**
In the `handleBeforeMount` callback, inside the `if (!schemaConfigured.current)` block:
1. Import `registerYamlFormatter` from `@/lib/yaml-formatter`
2. After calling `configureYamlSchema(monaco)`, call `registerYamlFormatter(monaco)` and store the returned disposable in a `useRef<IDisposable | null>(null)` (named `formatterDisposableRef`)
3. Also store the disposable returned by `configureYamlSchema(monaco)` in another ref `yamlConfigDisposableRef`
4. Add a `useEffect` cleanup that disposes the formatter disposable on component unmount (but NOT the yamlConfig disposable, since `configureMonacoYaml` is global/singleton)

The key change in `handleBeforeMount`:
```typescript
if (!schemaConfigured.current) {
  yamlConfigDisposableRef.current = configureYamlSchema(monaco);
  formatterDisposableRef.current = registerYamlFormatter(monaco);
  schemaConfigured.current = true;
}
```

And add cleanup effect:
```typescript
useEffect(() => {
  return () => {
    formatterDisposableRef.current?.dispose();
    formatterDisposableRef.current = null;
  };
}, []);
```

**Acceptance:**
- `cd rulez_ui && npx tsc --noEmit` passes
- `cd rulez_ui && npx biome check src/lib/yaml-formatter.ts src/components/editor/YamlEditor.tsx` passes (lint clean)
- Clicking the Format button in the toolbar actually formats the YAML (previously was a no-op)
- YAML comments are preserved after formatting
- Formatting broken YAML (syntax errors) does nothing (no crash, no data loss)

## Verification
1. `cd rulez_ui && npx tsc --noEmit` — no type errors
2. `cd rulez_ui && npx biome check .` — no lint errors
3. Open the app (`cd rulez_ui && npm run dev`), create or open a hooks.yaml file
4. Type a field name like `ver` and verify autocomplete suggests `version`
5. Type a rule field like `mat` and verify autocomplete suggests `matchers`
6. Introduce invalid YAML and verify red squiggles appear
7. Click the Format button and verify the YAML is re-indented
8. Add a YAML comment (`# my comment`), format, verify comment is preserved

## Dependencies
- Phase 11 must be complete (settings store with font size/theme — already done)
- No dependencies on Plan 02 or Plan 03
