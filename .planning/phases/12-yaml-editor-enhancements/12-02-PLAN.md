# Phase 12 Plan 02: Memory Management & Disposal Patterns

## Wave
Wave 1 (can execute in parallel with Plan 01)

## Objective
Fix all memory leaks in the Monaco editor integration: dispose marker listeners on unmount, dispose cursor/selection listeners, track disposables properly, and add model cleanup when files are closed in configStore.

## Why This Plan Exists
Satisfies success criteria:
5. **Editor properly disposes Monaco models and workers when switching between files (no memory leaks after 10+ file switches)** (EDIT-05)

Also fixes the existing marker listener leak (EDIT-06) — `onDidChangeMarkers` is subscribed in `handleMount` but the returned `IDisposable` is never stored or cleaned up, causing duplicate listeners on React Strict Mode remounts.

## Tasks

### Task 1: Track and dispose all Monaco event listeners in YamlEditor
**File(s):**
- `rulez_ui/src/components/editor/YamlEditor.tsx`

**Action:**
The current `handleMount` callback creates three event subscriptions that are never disposed:
1. `editorInstance.onDidChangeCursorPosition(...)` — line 65
2. `editorInstance.onDidChangeCursorSelection(...)` — line 73
3. `monaco.editor.onDidChangeMarkers(...)` — line 90

All three return `IDisposable` objects that must be tracked and cleaned up.

**Changes:**

1. Add a `disposablesRef = useRef<IDisposable[]>([])` to collect all disposables created during the editor's lifetime.

2. In `handleMount`, store each subscription's return value:
```typescript
const cursorDisposable = editorInstance.onDidChangeCursorPosition((e) => { ... });
disposablesRef.current.push(cursorDisposable);

const selectionDisposable = editorInstance.onDidChangeCursorSelection((e) => { ... });
disposablesRef.current.push(selectionDisposable);

const markerDisposable = monaco.editor.onDidChangeMarkers((uris) => { ... });
disposablesRef.current.push(markerDisposable);
```

3. Also track the `addCommand` disposable (Ctrl+S keybinding):
```typescript
const saveCommandDisposable = editorInstance.addCommand(
  monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS,
  () => { onSave?.(); }
);
// addCommand returns string | null, not IDisposable — no disposal needed
```
Note: `addCommand` does NOT return a disposable. The command is tied to the editor instance lifetime. No change needed here.

4. Add a cleanup `useEffect` that disposes all tracked disposables on unmount:
```typescript
useEffect(() => {
  return () => {
    for (const d of disposablesRef.current) {
      d.dispose();
    }
    disposablesRef.current = [];
  };
}, []);
```

5. **Critical:** Before subscribing new listeners in `handleMount`, dispose any existing ones (handles React Strict Mode double-mount):
```typescript
// At the start of handleMount, before creating new subscriptions:
for (const d of disposablesRef.current) {
  d.dispose();
}
disposablesRef.current = [];
```

6. Also clear the editorRef on unmount by setting `setEditorRef(null)` in the cleanup effect.

**Acceptance:**
- `cd rulez_ui && npx tsc --noEmit` passes
- `cd rulez_ui && npx biome check src/components/editor/YamlEditor.tsx` passes
- All three event subscriptions (`onDidChangeCursorPosition`, `onDidChangeCursorSelection`, `onDidChangeMarkers`) have their disposables tracked in `disposablesRef`
- The cleanup `useEffect` disposes all of them on unmount
- React Strict Mode double-mount does not create duplicate listeners

### Task 2: Add model cleanup on file close + use `path` prop for model reuse
**File(s):**
- `rulez_ui/src/components/layout/MainContent.tsx`
- `rulez_ui/src/components/editor/YamlEditor.tsx`

**Action:**

**Part A: Use the `path` prop on `<Editor>` for automatic model reuse**

The `@monaco-editor/react` `<Editor>` component supports a `path` prop that tells it to create/reuse models by URI. Currently the component only uses `value` without `path`, which means it creates new internal models on each render and may not properly clean up old ones.

In `YamlEditor.tsx`:
1. Add a `path` prop to the `YamlEditorProps` interface: `path?: string;`
2. Pass it through to the `<Editor>` component: `<Editor path={path} ... />`

In `MainContent.tsx`:
1. Pass `activeFile` as the `path` prop to `<YamlEditor>`:
```tsx
<YamlEditor
  value={activeContent}
  path={activeFile}
  onChange={(val) => updateContent(activeFile, val)}
  onSave={handleSave}
/>
```

This tells `@monaco-editor/react` to use `activeFile` as the model URI, so switching between files reuses models by path instead of destroying/recreating them.

**Part B: Dispose models when files are closed**

In `MainContent.tsx`, add a `useEffect` that watches `openFiles` and disposes Monaco models for files that were removed:

```typescript
import * as monaco from "monaco-editor";
```

Wait — `monaco-editor` is loaded asynchronously via `@monaco-editor/react`. We can't import it statically. Instead, use the `loader` from `@monaco-editor/react`:

```typescript
import { loader } from "@monaco-editor/react";
```

Add a `useRef` to track previously open file paths and a `useEffect`:

```typescript
const prevOpenFilesRef = useRef<Set<string>>(new Set());

useEffect(() => {
  const currentPaths = new Set(openFiles.keys());
  const closedPaths: string[] = [];
  
  for (const path of prevOpenFilesRef.current) {
    if (!currentPaths.has(path)) {
      closedPaths.push(path);
    }
  }
  
  if (closedPaths.length > 0) {
    // Dispose Monaco models for closed files
    loader.init().then((monaco) => {
      for (const path of closedPaths) {
        const uri = monaco.Uri.parse(path);
        const model = monaco.editor.getModel(uri);
        model?.dispose();
      }
    });
  }
  
  prevOpenFilesRef.current = currentPaths;
}, [openFiles]);
```

Also destructure `openFiles` from `useConfigStore` in the existing destructuring.

**Important:** The `path` prop value passed to `<Editor>` is used directly as the model's URI by `@monaco-editor/react`. The `loader.init()` gives us the same Monaco instance. So `monaco.editor.getModel(monaco.Uri.parse(path))` will find the correct model.

**Acceptance:**
- `cd rulez_ui && npx tsc --noEmit` passes
- `cd rulez_ui && npx biome check src/components/layout/MainContent.tsx src/components/editor/YamlEditor.tsx` passes
- Opening 10+ files and closing them does not leave orphaned models (if you check `monaco.editor.getModels().length` in dev tools, it should not grow unbounded)
- Switching between open files preserves cursor position (the `path` prop handles this)
- Closing a file tab triggers model disposal

## Verification
1. `cd rulez_ui && npx tsc --noEmit` — no type errors
2. `cd rulez_ui && npx biome check .` — no lint errors
3. Open the app, open 3-4 files, switch between them rapidly — no console errors, no duplicate validation messages
4. Close all files, open dev tools, run `monaco.editor.getModels().length` in console — should be 0 or 1 (only the active model if one file is open)
5. In React Strict Mode (dev), verify no duplicate marker listener calls (add a `console.log` temporarily in the marker handler — should fire once per change, not 2x)

## Dependencies
- Phase 11 must be complete (already done)
- No dependencies on Plan 01 (this plan touches YamlEditor.tsx and MainContent.tsx independently — Plan 01 also touches YamlEditor.tsx's `handleBeforeMount` but this plan touches `handleMount` and adds refs/effects, so they modify different sections)
- **Note for executor:** If Plan 01 and Plan 02 are executed in the same session, merge the YamlEditor.tsx changes carefully. Plan 01 adds `formatterDisposableRef` and `yamlConfigDisposableRef` to `handleBeforeMount`. Plan 02 adds `disposablesRef` to `handleMount` and a cleanup effect. These do not conflict.
