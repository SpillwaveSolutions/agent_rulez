# Phase 12 Plan 03: Format-on-Save + Integration Verification

## Wave
Wave 2 (must execute after Plans 01 and 02)

## Objective
Wire format-on-save so YAML is auto-formatted before writing to disk, and perform end-to-end verification that all five success criteria are met with the changes from Plans 01 and 02 integrated.

## Why This Plan Exists
Satisfies success criteria:
4. **User can format/indent YAML on save or via keyboard shortcut** (EDIT-04, the "on save" half)
3. **User can click errors in error panel to jump directly to the corresponding line** (EDIT-03, verification — already built, needs confirmation it still works with new model management)

Also serves as integration verification for all Phase 12 work.

## Tasks

### Task 1: Wire format-on-save in MainContent handleSave
**File(s):**
- `rulez_ui/src/components/layout/MainContent.tsx`

**Action:**
The current `handleSave` directly writes `getActiveContent()` to disk. After Plan 01 registers a formatting provider, we need `handleSave` to trigger formatting BEFORE saving so the file is written with consistent indentation.

Modify `handleSave` to:
1. Get the editor ref from `useEditorStore.getState().editorRef`
2. If the editor ref exists, trigger `editor.action.formatDocument` and await it
3. After formatting completes, re-read the content from the store (formatting changes the model value, which triggers `onChange`, which updates configStore)
4. Then write the formatted content to disk

```typescript
const handleSave = useCallback(async () => {
  if (!activeFile) return;

  // Format before saving (if formatting provider is registered)
  const editorRef = useEditorStore.getState().editorRef;
  if (editorRef) {
    const formatAction = editorRef.getAction("editor.action.formatDocument");
    if (formatAction) {
      await formatAction.run();
    }
  }

  // Re-read content after formatting (formatting updates the model -> onChange -> configStore)
  const content = useConfigStore.getState().getActiveContent();
  if (content === null) return;
  try {
    await writeConfig(activeFile, content);
    markSaved(activeFile);
  } catch (err) {
    console.error("Failed to save file:", err);
  }
}, [activeFile, markSaved]);
```

Add the import for `useEditorStore`:
```typescript
import { useEditorStore } from "@/stores/editorStore";
```

**Important:** The `formatAction.run()` is async — it applies the edits from the formatting provider to the model. The model's `onDidChangeContent` fires, which triggers the `onChange` prop on `<Editor>`, which calls `updateContent` in configStore. So after `await formatAction.run()`, the configStore has the formatted content.

**Note:** If the YAML has parse errors, the formatting provider (from Plan 01) returns empty edits, so formatting is a no-op and save proceeds with the unformatted content. This is the correct behavior — don't block saves on formatting failures.

**Acceptance:**
- `cd rulez_ui && npx tsc --noEmit` passes
- `cd rulez_ui && npx biome check src/components/layout/MainContent.tsx` passes
- Pressing Ctrl+S formats the YAML AND saves the file (both happen)
- If the YAML has syntax errors, Ctrl+S still saves (formatting is skipped, save proceeds)

### Task 2: Add Ctrl+Shift+I keyboard shortcut for format in YamlEditor
**File(s):**
- `rulez_ui/src/components/editor/YamlEditor.tsx`

**Action:**
Monaco's built-in `editor.action.formatDocument` is typically bound to Shift+Alt+F. Add a more discoverable Ctrl+Shift+I binding (common in web dev tools) as an additional shortcut.

In `handleMount`, after the existing Ctrl+S command registration, add:
```typescript
editorInstance.addCommand(
  monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KeyI,
  () => {
    editorInstance.getAction("editor.action.formatDocument")?.run();
  }
);
```

This doesn't replace the existing Shift+Alt+F default — it adds an additional binding.

**Acceptance:**
- `cd rulez_ui && npx tsc --noEmit` passes
- Pressing Ctrl+Shift+I (Cmd+Shift+I on Mac) formats the document
- The existing Shift+Alt+F shortcut also still works

### Task 3: End-to-end integration verification
**File(s):** None (verification only)

**Action:**
Run the full verification suite to confirm all five success criteria:

1. **Schema autocomplete (SC1):** Open a hooks.yaml, position cursor inside a rule object, type a field prefix (e.g., `de`) — verify autocomplete suggests `description`. Type `mat` — verify `matchers` is suggested. Under `matchers:`, type `to` — verify `tools` is suggested.

2. **Error markers (SC2):** Introduce a YAML syntax error (e.g., bad indentation, missing colon). Verify red squiggly underlines appear on the problematic lines. Add an invalid schema field (e.g., `invalid_field: true` at root level with `additionalProperties: false`). Verify a warning/error marker appears.

3. **Click-to-navigate (SC3):** With errors visible in the ValidationPanel, click an error entry. Verify the editor scrolls to and highlights the corresponding line.

4. **Format (SC4):** Open a file with messy indentation. Press the Format toolbar button — verify YAML is re-indented. Press Ctrl+S — verify format happens before save (check the file on disk has clean indentation). Verify comments are preserved.

5. **Memory management (SC5):** Open 5 files in tabs, switch between them. Close all 5 files. Open dev tools console, check `monaco.editor.getModels().length` equals 0 (or 1 if one file remains open). No console errors about duplicate listeners.

**Acceptance:**
- All five success criteria pass manual verification
- `cd rulez_ui && npx tsc --noEmit` passes
- `cd rulez_ui && npx biome check .` passes
- No console errors during normal editor usage

## Verification
1. `cd rulez_ui && npx tsc --noEmit` — no type errors across entire project
2. `cd rulez_ui && npx biome check .` — full lint pass
3. `cd rulez_ui && npm run build` — production build succeeds (confirms Vite can resolve the JSON schema import)
4. All 5 success criteria verified manually (see Task 3)

## Dependencies
- **Plan 01 must be complete** — format-on-save depends on the formatting provider being registered
- **Plan 02 must be complete** — memory verification depends on disposal patterns being in place
- Both Plans 01 and 02 modify `YamlEditor.tsx` — this plan's changes to `YamlEditor.tsx` (Task 2) must be applied on top of the merged result from Plans 01+02
