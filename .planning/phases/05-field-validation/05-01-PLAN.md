---
phase: 05-field-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rulez/src/models.rs
  - rulez/src/config.rs
autonomous: true

must_haves:
  truths:
    - "require_fields and field_types deserialize correctly from YAML"
    - "Invalid field paths are rejected at config load time"
    - "Invalid type specifiers are rejected at config load time"
    - "Dot notation field paths are validated for syntax correctness"
    - "Dot-to-pointer conversion produces correct JSON Pointer paths"
  artifacts:
    - path: "rulez/src/models.rs"
      provides: "require_fields and field_types fields in Matchers struct, dot_to_pointer utility"
      contains: "require_fields"
    - path: "rulez/src/config.rs"
      provides: "Config validation for require_fields paths and field_types specifiers"
      contains: "require_fields"
  key_links:
    - from: "rulez/src/config.rs"
      to: "rulez/src/models.rs"
      via: "Matchers struct fields require_fields and field_types"
      pattern: "require_fields|field_types"
---

<objective>
Add field validation types to the Matchers struct and validate field paths and type specifiers at config load time.

Purpose: Establish the data model and configuration-time validation for field validation, following the same pattern established in Phase 4 (prompt_match). This is the foundation that Plan 02 builds matching logic on.

Output: Updated models.rs with require_fields/field_types in Matchers, dot_to_pointer utility function, and config.rs validation for field paths and type specifiers.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-field-validation/05-CONTEXT.md
@.planning/phases/05-field-validation/05-RESEARCH.md
@.planning/phases/04-prompt-matching/04-01-SUMMARY.md
@.planning/phases/04-prompt-matching/04-03-SUMMARY.md
@rulez/src/models.rs
@rulez/src/config.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add require_fields, field_types to Matchers struct and dot_to_pointer utility</name>
  <files>rulez/src/models.rs</files>
  <action>
  Add two new optional fields to the Matchers struct (after prompt_match):

  ```rust
  /// Required field paths that must exist in tool_input JSON
  /// Dot notation for nested fields: ["file_path", "input.user.name"]
  #[serde(skip_serializing_if = "Option::is_none")]
  pub require_fields: Option<Vec<String>>,

  /// Expected types for fields in tool_input JSON
  /// Keys are field paths (dot notation), values are type specifiers
  /// Supported types: string, number, boolean, array, object, any
  /// Implicitly requires field existence (field_types implies require_fields)
  #[serde(skip_serializing_if = "Option::is_none")]
  pub field_types: Option<std::collections::HashMap<String, String>>,
  ```

  Add a new section after the PromptMatch impl block (around line 269) with field validation utilities:

  ```rust
  // =============================================================================
  // Phase 5: Field Validation Utilities
  // =============================================================================

  /// Convert dot-notation field path to JSON Pointer format (RFC 6901)
  ///
  /// Examples:
  /// - "file_path" -> "/file_path"
  /// - "user.name" -> "/user/name"
  /// - "input.user.address.city" -> "/input/user/address/city"
  ///
  /// Handles RFC 6901 escaping: ~ becomes ~0, / becomes ~1
  pub fn dot_to_pointer(field_path: &str) -> String {
      let escaped_segments: Vec<String> = field_path
          .split('.')
          .map(|segment| {
              segment.replace('~', "~0").replace('/', "~1")
          })
          .collect();
      format!("/{}", escaped_segments.join("/"))
  }
  ```

  Update ALL existing test helper Matchers instantiations in models.rs to include the new fields:
  - Add `require_fields: None,` and `field_types: None,` to every Matchers literal in test code

  Also add unit tests for dot_to_pointer:
  - Simple field: "name" -> "/name"
  - Nested: "user.name" -> "/user/name"
  - Deep nested: "a.b.c.d" -> "/a/b/c/d"
  - Special chars: "user~name" -> "/user~0name"
  - Slash in name: "path/to" -> "/path~1to"

  Do NOT add jsonschema or any new dependency. serde_json is already available.
  </action>
  <verify>
  `cargo check --package rulez` passes with no errors.
  `cargo test --package rulez -- dot_to_pointer` passes all pointer conversion tests.
  </verify>
  <done>
  Matchers struct has require_fields (Option Vec String) and field_types (Option HashMap String String) fields. dot_to_pointer function correctly converts dot notation to JSON Pointer format. All existing tests still pass with the new fields added.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add config-time validation for require_fields and field_types</name>
  <files>rulez/src/config.rs</files>
  <action>
  Add validation logic to Config::validate() method (after the existing prompt_match validation block, before the closing `Ok(())`):

  **require_fields validation:**
  - If require_fields is Some, reject empty arrays
  - For each field path:
    - Reject empty strings
    - Reject paths starting with '.' (e.g., ".name")
    - Reject paths ending with '.' (e.g., "name.")
    - Reject paths with consecutive dots (e.g., "name..field")
    - Reject paths with empty segments between dots
  - Error format: `"Invalid field path '{}' in require_fields for rule '{}': {reason}"`

  **field_types validation:**
  - For each (field_path, type_specifier) pair:
    - Validate the field path using same rules as require_fields above
    - Validate type_specifier is one of: "string", "number", "boolean", "array", "object", "any"
    - Error format: `"Invalid type '{}' for field '{}' in field_types for rule '{}': must be one of string, number, boolean, array, object, any"`

  Add validation unit tests:
  - test_require_fields_valid_simple: ["file_path", "content"] accepted
  - test_require_fields_valid_nested: ["user.name", "input.data.value"] accepted
  - test_require_fields_empty_array_rejected: empty [] rejected
  - test_require_fields_empty_string_rejected: [""] rejected
  - test_require_fields_leading_dot_rejected: [".name"] rejected
  - test_require_fields_trailing_dot_rejected: ["name."] rejected
  - test_require_fields_consecutive_dots_rejected: ["name..field"] rejected
  - test_field_types_valid: {file_path: string, count: number} accepted
  - test_field_types_invalid_type_rejected: {count: integer} rejected (not a valid type)
  - test_field_types_invalid_path_rejected: {".name": string} rejected
  - test_field_types_any_type_accepted: {data: any} accepted

  Update existing test Matchers instantiations in config.rs to include `require_fields: None, field_types: None,`.
  </action>
  <verify>
  `cargo check --package rulez` passes.
  `cargo test --package rulez -- test_require_fields` passes all require_fields validation tests.
  `cargo test --package rulez -- test_field_types` passes all field_types validation tests.
  `cargo test --package rulez` — all tests pass (no regressions).
  </verify>
  <done>
  Config::validate() rejects invalid field paths (empty, leading/trailing dots, consecutive dots) and invalid type specifiers (anything not in string/number/boolean/array/object/any). All validation happens at config load time. Error messages include rule name and the offending field path. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
- `cargo check --package rulez` compiles without errors
- `cargo test --package rulez` — all tests pass including new ones
- Matchers struct has require_fields and field_types fields
- dot_to_pointer correctly converts dot notation to JSON Pointer
- Config validation rejects invalid field paths and type specifiers at load time
</verification>

<success_criteria>
- require_fields and field_types fields exist in Matchers struct and deserialize from YAML
- dot_to_pointer conversion handles simple, nested, and special character paths
- Config validation catches malformed field paths before runtime
- Config validation catches invalid type specifiers before runtime
- All 407+ existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-field-validation/05-01-SUMMARY.md`
</output>
