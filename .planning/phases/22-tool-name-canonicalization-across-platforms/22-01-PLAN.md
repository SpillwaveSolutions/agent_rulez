---
phase: 22-tool-name-canonicalization-across-platforms
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rulez/src/adapters/gemini.rs
  - rulez/src/adapters/copilot.rs
  - rulez/src/adapters/opencode.rs
  - rulez/tests/gemini_adapter.rs
  - rulez/tests/copilot_adapter.rs
  - rulez/tests/opencode_payload_tests.rs
autonomous: true

must_haves:
  truths:
    - "A rule with `tools: [Bash]` fires for Gemini's `run_shell_command`, Copilot's `shell`, and OpenCode's `bash`"
    - "Unknown/custom tool names pass through unchanged without `platform_tool_name` injection"
    - "The original platform tool name is preserved in `tool_input.platform_tool_name` when mapping occurs"
    - "The codebase compiles without errors (`cargo build` succeeds)"
    - "All adapter tests pass with canonical name assertions"
  artifacts:
    - path: "rulez/src/adapters/gemini.rs"
      provides: "Compile-safe tool name canonicalization using Map-first pattern; corrected Gemini tool name mappings"
      contains: "map_tool_name"
    - path: "rulez/src/adapters/copilot.rs"
      provides: "Compile-safe tool name canonicalization using Map-first pattern"
      contains: "map_tool_name"
    - path: "rulez/src/adapters/opencode.rs"
      provides: "Added webfetch mapping alongside existing fetch mapping"
      contains: "webfetch"
    - path: "rulez/tests/gemini_adapter.rs"
      provides: "Tests asserting canonical names and platform_tool_name preservation"
      contains: "platform_tool_name"
    - path: "rulez/tests/copilot_adapter.rs"
      provides: "Tests asserting canonical names and platform_tool_name preservation"
      contains: "platform_tool_name"
    - path: "rulez/tests/opencode_payload_tests.rs"
      provides: "Tests asserting canonical names and platform_tool_name preservation"
      contains: "platform_tool_name"
  key_links:
    - from: "rulez/src/adapters/gemini.rs"
      to: "rulez/tests/gemini_adapter.rs"
      via: "parse_event returns Event with canonical tool_name"
      pattern: "tool_name.*Some.*Write"
    - from: "rulez/src/adapters/copilot.rs"
      to: "rulez/tests/copilot_adapter.rs"
      via: "parse_event returns Event with canonical tool_name"
      pattern: "tool_name.*Some.*Bash"
    - from: "rulez/src/adapters/opencode.rs"
      to: "rulez/tests/opencode_payload_tests.rs"
      via: "parse_event returns Event with canonical tool_name"
      pattern: "tool_name.*Some.*Bash"
---

<objective>
Fix the Rust compile errors in gemini.rs and copilot.rs adapters, correct Gemini tool name mappings to match official docs, add `webfetch` mapping to OpenCode, and update all adapter tests to assert canonical tool names with platform_tool_name preservation.

Purpose: The map_tool_name() functions were added in Phase 21 but left the codebase in a non-compiling state due to a Rust ownership bug. The Gemini mappings also use incorrect platform tool names. This plan fixes both issues and brings test coverage up to date.

Output: All 3 adapters compile and correctly canonicalize tool names; all adapter tests pass with canonical name assertions.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-tool-name-canonicalization-across-platforms/22-RESEARCH.md
@rulez/src/adapters/opencode.rs (reference — working Map-first pattern to replicate)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix adapter compile errors and correct tool name mappings</name>
  <files>
    rulez/src/adapters/gemini.rs
    rulez/src/adapters/copilot.rs
    rulez/src/adapters/opencode.rs
  </files>
  <action>
**gemini.rs — Fix compile error + correct mappings:**

1. Refactor `parse_event()` to use the Map-first pattern from `opencode.rs`. Replace the current flow:
   - Remove the call to `merge_tool_input()` (lines 54-58)
   - Instead, inline the merge logic: unwrap `input.tool_input` into a `Map<String, Value>` directly, then merge `input.extra` into it using `entry().or_insert()`
   - Handle `preserve_name` by inserting `gemini_hook_event_name` into the map directly
   - The canonicalization block (lines 61-72) stays the same
   - Replace the broken `if let` block (lines 75-85) with the OpenCode pattern: `if let Some(ref orig) = original_tool_name { tool_input_map.insert(...) }`
   - Wrap the final Map in `Option<Value>` at the end: `if tool_input_map.is_empty() { None } else { Some(Value::Object(tool_input_map)) }`

2. Correct `map_tool_name()` mappings to match verified Gemini CLI docs:
   - `"execute_code"` => keep as alias, ADD `"run_shell_command"` => `"Bash"` (both map to Bash)
   - `"list_files"` => REMOVE (incorrect), already have `"glob"` implicit pass-through — but Gemini's tool IS called `"glob"`, so add `"glob" => "Glob"` explicitly
   - `"search_files"` => REPLACE with `"search_file_content" | "grep_search"` => `"Grep"`
   - `"run_agent"` => REMOVE (unverified, let it pass through)
   - Keep: `"write_file" => "Write"`, `"replace" => "Edit"`, `"read_file" => "Read"`, `"web_fetch" => "WebFetch"`

3. The `merge_tool_input()` helper function can be removed since it is no longer called (it was only used by `parse_event`). If other code references it, keep it but it should be dead code — check first.

**copilot.rs — Fix compile error:**

1. Apply the same Map-first refactor to `parse_event()`:
   - Remove the call to `merge_tool_input()` (lines 41-45)
   - Inline the merge: unwrap `input.tool_input` to `Map<String, Value>`, merge `input.extra`, handle `preserve_name` with `copilot_hook_event_name`
   - Replace the broken `if let` block (lines 62-72) with the OpenCode pattern
   - Wrap in `Option<Value>` at the end

2. The `merge_tool_input()` helper can be removed if unused. Copilot `map_tool_name()` mappings are LOW confidence but acceptable as-is — no changes needed.

**opencode.rs — Add webfetch mapping:**

1. In `map_tool_name()`, change `"fetch" => "WebFetch"` to `"webfetch" | "fetch" => "WebFetch"` so both the official name (`webfetch`) and the current mapped name (`fetch`) work.

**Verification after all changes:**
- Run `cargo build --workspace` to confirm compile errors are resolved
  </action>
  <verify>
    `cargo build --workspace` succeeds with no errors.
    `cargo clippy --all-targets --all-features --workspace -- -D warnings` passes.
  </verify>
  <done>
    All 3 adapter files compile. Gemini mappings match verified official docs. OpenCode handles both `webfetch` and `fetch`. The Rust ownership bug in gemini.rs and copilot.rs is eliminated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update adapter tests for canonical tool name assertions</name>
  <files>
    rulez/tests/gemini_adapter.rs
    rulez/tests/copilot_adapter.rs
    rulez/tests/opencode_payload_tests.rs
  </files>
  <action>
**gemini_adapter.rs:**

1. Update `test_parse_tool_event_maps_pre_tool_use`:
   - Change assertion from `Some("write_file")` to `Some("Write")` (canonical name)
   - Add assertion: `map.get("platform_tool_name").and_then(|v| v.as_str())` equals `Some("write_file")`

2. Add new test `test_tool_name_canonicalized_bash`:
   - Input: `tool_name: "run_shell_command"`, `hook_event_name: "BeforeTool"`, `tool_input: {"command": "ls"}`
   - Assert: `tool_name == Some("Bash")`, `tool_input["platform_tool_name"] == "run_shell_command"`

3. Add new test `test_unknown_tool_passes_through`:
   - Input: `tool_name: "mcp__custom__tool"`, `hook_event_name: "BeforeTool"`, `tool_input: {"arg": "val"}`
   - Assert: `tool_name == Some("mcp__custom__tool")`, `tool_input.get("platform_tool_name").is_none()`

4. Add new test `test_no_tool_name_event`:
   - Input: `hook_event_name: "BeforeAgent"`, no `tool_name` field
   - Assert: `tool_name.is_none()`

**copilot_adapter.rs:**

1. Update `test_parse_tool_event_maps_pre_tool_use`:
   - Change assertion from `Some("shell")` to `Some("Bash")` (canonical name)
   - Add assertion: `map.get("platform_tool_name").and_then(|v| v.as_str())` equals `Some("shell")`

2. Add new test `test_unknown_tool_passes_through`:
   - Input: `tool_name: "custom_tool"`, `hook_event_name: "preToolUse"`, `tool_input: {"arg": "val"}`
   - Assert: `tool_name == Some("custom_tool")`, `tool_input.get("platform_tool_name").is_none()`

3. Update `test_translate_response_allow_deny` — the tool_name `"shell"` used in the test setup will now parse to `"Bash"` internally. This should still work for response translation (it doesn't depend on tool_name value). Verify no assertion changes needed.

**opencode_payload_tests.rs:**

1. Update `test_parse_tool_execute_before`:
   - Change assertion from `Some("bash".to_string())` to `Some("Bash".to_string())` (canonical name)
   - Add assertion: `tool_input["platform_tool_name"] == "bash"`

2. Add new test `test_tool_name_canonicalized_webfetch`:
   - Input: `tool_name: "webfetch"`, `hook_event_name: "tool.execute.before"`, `tool_input: {"url": "https://example.com"}`
   - Assert: `tool_name == Some("WebFetch".to_string())`, `tool_input["platform_tool_name"] == "webfetch"`

3. Add new test `test_unknown_tool_passes_through`:
   - Input: `tool_name: "custom_mcp_tool"`, `hook_event_name: "tool.execute.before"`, `tool_input: {"arg": "val"}`
   - Assert: `tool_name == Some("custom_mcp_tool".to_string())`, `tool_input.get("platform_tool_name").is_none()`
  </action>
  <verify>
    `cargo test --tests --all-features --workspace` — all tests pass.
    `cargo clippy --all-targets --all-features --workspace -- -D warnings` — no warnings.
    `cargo fmt --all --check` — formatting correct.
  </verify>
  <done>
    All adapter tests assert canonical tool names. Each adapter has tests covering: mapped tool (canonical name + platform_tool_name preserved), unknown tool (passes through, no platform_tool_name), and no-tool-name event. Full CI pipeline passes locally.
  </done>
</task>

</tasks>

<verification>
1. `cargo fmt --all --check` — no formatting issues
2. `cargo clippy --all-targets --all-features --workspace -- -D warnings` — no warnings
3. `cargo test --tests --all-features --workspace` — all tests pass
4. `cargo llvm-cov --all-features --workspace --no-report` — coverage run passes (catches pipe/process bugs)
5. Spot-check: `cargo test gemini_adapter` shows canonical name assertions passing
6. Spot-check: `cargo test copilot_adapter` shows canonical name assertions passing
7. Spot-check: `cargo test opencode_payload` shows canonical name assertions passing
</verification>

<success_criteria>
- The codebase compiles (`cargo build` succeeds — was broken before)
- All 3 adapters canonicalize known platform tool names to PascalCase Claude Code names
- All 3 adapters preserve the original platform name in `tool_input.platform_tool_name`
- Unknown tool names pass through unchanged with no `platform_tool_name` injected
- Gemini mappings use verified official tool names (run_shell_command, glob, search_file_content/grep_search)
- OpenCode handles both `webfetch` (official) and `fetch` (legacy) for WebFetch
- Full CI pipeline passes locally (fmt + clippy + test + llvm-cov)
</success_criteria>

<output>
After completion, create `.planning/phases/22-tool-name-canonicalization-across-platforms/22-01-SUMMARY.md`
</output>
