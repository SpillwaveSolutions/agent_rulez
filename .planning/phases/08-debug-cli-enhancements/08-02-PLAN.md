---
phase: 08-debug-cli-enhancements
plan: 02
type: tdd
wave: 2
depends_on: ["08-01"]
files_modified:
  - rulez/src/hooks.rs
  - rulez/Cargo.toml
  - Cargo.toml
autonomous: true

must_haves:
  truths:
    - "REGEX_CACHE never grows beyond 100 entries regardless of unique patterns processed"
    - "User runs debug command twice and second invocation has clean state (no REGEX_CACHE contamination)"
    - "LRU eviction removes least-recently-used patterns when cache reaches capacity"
    - "Existing regex caching behavior (compile once, reuse) is preserved"
  artifacts:
    - path: "rulez/src/hooks.rs"
      provides: "LRU-based REGEX_CACHE with 100 entry cap"
      contains: "LruCache"
    - path: "rulez/Cargo.toml"
      provides: "lru dependency"
      contains: "lru"
  key_links:
    - from: "rulez/src/hooks.rs"
      to: "rulez/Cargo.toml"
      via: "lru crate dependency"
      pattern: "use lru::LruCache"
    - from: "rulez/src/cli/debug.rs"
      to: "rulez/src/hooks.rs"
      via: "REGEX_CACHE.lock().unwrap().clear() for state isolation"
      pattern: "REGEX_CACHE.*clear"
---

<objective>
Replace the unbounded HashMap REGEX_CACHE with an LRU cache (max 100 entries) and add state isolation tests verifying no cross-invocation cache leakage.

Purpose: The current REGEX_CACHE is an unbounded HashMap that grows without limit. This is tech debt from Phase 4 (prompt matching). LRU eviction bounds memory usage and the state isolation tests verify debug CLI correctness.
Output: Updated hooks.rs with LRU cache, new lru dependency, state isolation unit tests.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-debug-cli-enhancements/08-01-SUMMARY.md

Key files to read before implementing:
@rulez/src/hooks.rs — REGEX_CACHE (lines 30-64), get_or_compile_regex()
@rulez/Cargo.toml — Current dependencies
@Cargo.toml — Workspace dependencies
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add lru dependency and replace HashMap REGEX_CACHE with LruCache</name>
  <files>rulez/Cargo.toml, Cargo.toml, rulez/src/hooks.rs</files>
  <action>
**TDD RED phase — write failing tests first:**

In `rulez/src/hooks.rs`, in the existing `#[cfg(test)] mod tests` section, add these tests:

1. **`test_regex_cache_lru_eviction`** — Compile 101 unique patterns. After the 101st insertion, verify that calling `get_or_compile_regex` with the 1st pattern requires recompilation (it was evicted). Verify by checking cache size is 100 (expose a `regex_cache_len()` test helper if needed). Use patterns like `format!("pattern_{}", i)` for unique strings.

2. **`test_regex_cache_clear_isolates_state`** — Compile several patterns, then call `REGEX_CACHE.lock().unwrap().clear()`, then verify cache is empty (len() == 0). This models what debug run() does.

3. **`test_regex_cache_get_refreshes_entry`** — Insert patterns A, B, C (cache cap 100 is large enough for this). Access pattern A again. Insert 97 more patterns to fill to 100. Insert one more. Pattern A should still be in cache (it was recently used) while pattern B (least recently used) should be evicted.

Run tests — they should FAIL because HashMap has no size cap and no LRU eviction.

**TDD GREEN phase — implement LRU cache:**

1. Add `lru = "0.12"` to `Cargo.toml` workspace dependencies section.
2. Add `lru.workspace = true` to `rulez/Cargo.toml` dependencies.

3. In `rulez/src/hooks.rs`:
   - Add `use lru::LruCache;` import
   - Add `use std::num::NonZeroUsize;`
   - Replace the REGEX_CACHE declaration:
   ```rust
   /// Maximum number of compiled regex patterns to cache.
   /// 100 covers typical config sizes while bounding memory.
   const REGEX_CACHE_MAX_SIZE: usize = 100;

   /// Global regex cache with LRU eviction.
   /// Patterns are compiled once and reused. When the cache reaches
   /// REGEX_CACHE_MAX_SIZE, the least-recently-used pattern is evicted.
   pub static REGEX_CACHE: LazyLock<Mutex<LruCache<String, Regex>>> =
       LazyLock::new(|| Mutex::new(LruCache::new(NonZeroUsize::new(REGEX_CACHE_MAX_SIZE).unwrap())));
   ```

   - Update `get_or_compile_regex()`:
     - Change `cache.get(&cache_key)` to `cache.get(&cache_key)` (LruCache::get takes &K and returns Option<&V>, and it updates the LRU order — this is the key semantic difference from HashMap)
     - Change `cache.insert(cache_key, regex.clone())` — LruCache::put is the insert method. Use `cache.put(cache_key, regex.clone())`
     - The first read block needs to clone the regex before dropping the lock. With LruCache, `get()` returns `Option<&V>` and updates recency. Clone the value:
     ```rust
     {
         let mut cache = REGEX_CACHE.lock().unwrap();
         if let Some(regex) = cache.get(&cache_key) {
             return Ok(regex.clone());
         }
     }
     ```
     Note: LruCache::get() takes `&mut self` (it updates LRU order), so the lock must be `let mut cache`.

   - Update insert to use `put()`:
     ```rust
     let mut cache = REGEX_CACHE.lock().unwrap();
     cache.put(cache_key, regex.clone());
     ```

4. Add a test helper function (inside `#[cfg(test)]` module or behind test feature):
```rust
#[cfg(test)]
pub fn regex_cache_len() -> usize {
    REGEX_CACHE.lock().unwrap().len()
}
```

Run the 3 tests again — they should now PASS.

**TDD REFACTOR phase:**
- Ensure doc comments on REGEX_CACHE explain the LRU policy
- Ensure REGEX_CACHE_MAX_SIZE is a named constant (not magic number)
- Run full test suite to verify no regressions
  </action>
  <verify>
Run:
- `cargo test --workspace -- test_regex_cache` — all 3 new LRU tests pass
- `cargo test --tests --all-features --workspace` — full test suite passes (no regressions from HashMap->LruCache change)
- `cargo clippy --all-targets --all-features --workspace -- -D warnings` — no warnings
  </verify>
  <done>
- REGEX_CACHE uses LruCache with 100 entry cap
- LRU eviction works (oldest unused entry removed when full)
- get() refreshes LRU order (recently accessed patterns are not evicted)
- clear() empties the cache completely (state isolation)
- All existing prompt_match and regex tests still pass
- 3 new unit tests verify LRU behavior
  </done>
</task>

</tasks>

<verification>
1. `cargo fmt --all --check` — no formatting issues
2. `cargo clippy --all-targets --all-features --workspace -- -D warnings` — no warnings
3. `cargo test --tests --all-features --workspace` — all tests pass (including 600+ existing)
4. `cargo llvm-cov --all-features --workspace --no-report` — coverage run passes
5. Verify REGEX_CACHE cannot grow beyond 100 entries (test_regex_cache_lru_eviction)
</verification>

<success_criteria>
- REGEX_CACHE is LRU-based with max 100 entries
- Eviction removes least-recently-used patterns
- get() refreshes entry recency
- clear() empties cache for debug state isolation
- All existing tests pass without modification (API-compatible change)
- 3 new TDD tests verify LRU behavior
</success_criteria>

<output>
After completion, create `.planning/phases/08-debug-cli-enhancements/08-02-SUMMARY.md`
</output>
