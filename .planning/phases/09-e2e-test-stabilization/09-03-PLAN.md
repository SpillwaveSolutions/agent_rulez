---
phase: 09-e2e-test-stabilization
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - rulez/tests/e2e_symlink_resolution.rs
  - rulez/tests/e2e_git_push_block.rs
autonomous: true

must_haves:
  truths:
    - "Symlink resolution test verifies RuleZ finds hooks.yaml when cwd is a symlink to the project directory"
    - "Symlink test is Unix-only (cfg(unix)) since Windows symlinks require elevated privileges"
    - "All E2E tests have explicit drop(temp_dir) at end for deterministic cleanup"
    - "No tempdir cleanup race conditions — all file handles are closed before drop"
    - "All 631+ existing tests continue to pass"
  artifacts:
    - path: "rulez/tests/e2e_symlink_resolution.rs"
      provides: "Unix-only symlink resolution E2E test"
      contains: "test_symlink_cwd_resolution"
    - path: "rulez/tests/e2e_git_push_block.rs"
      provides: "E2E tests with explicit tempdir cleanup via drop()"
      contains: "drop(temp_dir)"
  key_links:
    - from: "rulez/tests/e2e_symlink_resolution.rs"
      to: "rulez/tests/common/mod.rs"
      via: "Uses canonicalize_path(), setup_test_env(), TestEvidence, Timer from common"
      pattern: "canonicalize_path"
    - from: "rulez/tests/e2e_symlink_resolution.rs"
      to: "rulez/src/config.rs"
      via: "Tests that RuleZ config loader resolves symlinks to find hooks.yaml"
      pattern: "hooks.yaml"
---

<objective>
Add symlink resolution E2E tests (Unix-only) and add explicit tempdir cleanup (drop) to all E2E tests to prevent cleanup race conditions on Windows and CI.

Purpose: Validate that RuleZ correctly resolves symlinks when loading config (critical for macOS where /var -> /private/var). Add explicit drop(temp_dir) to prevent tempdir cleanup race conditions that cause intermittent failures in CI, especially on Windows.

Output: New e2e_symlink_resolution.rs test file, updated e2e_git_push_block.rs with explicit drop() calls.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-e2e-test-stabilization/09-RESEARCH.md
@.planning/phases/09-e2e-test-stabilization/09-01-SUMMARY.md

Key files to read before implementing:
@rulez/tests/common/mod.rs — canonicalize_path() (added in Plan 01), setup_test_env, TestEvidence, Timer
@rulez/tests/e2e_git_push_block.rs — 8 E2E tests (updated in Plan 01 with canonical paths)
@rulez/tests/fixtures/hooks/block-all-push.yaml — Fixture used by E2E tests
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create symlink resolution E2E test file</name>
  <files>rulez/tests/e2e_symlink_resolution.rs</files>
  <action>
Create a NEW file `rulez/tests/e2e_symlink_resolution.rs` with Unix-only symlink tests.

**File structure** (matches existing `e2e_git_push_block.rs` patterns -- flat file, no inner module):

```rust
//! End-to-End Tests: Symlink Resolution
//!
//! Validates that RuleZ correctly resolves symlinks when loading configuration.
//! These tests are Unix-only because Windows symlinks require elevated privileges.

#![allow(deprecated)]
#![allow(unused_imports)]

use assert_cmd::Command;
use std::fs;

#[path = "common/mod.rs"]
mod common;
use common::{TestEvidence, Timer, canonicalize_path, evidence_dir, setup_test_env};

/// Test 1: RuleZ finds hooks.yaml when cwd is a symlink to the project dir.
#[test]
#[cfg(unix)]
fn test_symlink_cwd_resolution() {
    use std::os::unix::fs::symlink;  // <-- import INSIDE function body (cfg-gated)

    let timer = Timer::start();
    let mut evidence = TestEvidence::new("e2e_symlink_cwd", "E2E");

    let temp_dir = setup_test_env("block-all-push.yaml");

    let symlink_dir = tempfile::tempdir().unwrap();
    let symlink_path = symlink_dir.path().join("link-to-project");
    symlink(temp_dir.path(), &symlink_path).expect("create symlink");

    let cwd = symlink_path.to_string_lossy().to_string();
    let event = serde_json::json!({
        "hook_event_name": "PreToolUse",
        "tool_name": "Bash",
        "tool_input": { "command": "git push" },
        "cwd": cwd,
        "session_id": "symlink-test"
    });

    let output = Command::cargo_bin("rulez")
        .expect("binary exists")
        .current_dir(&symlink_path)
        .write_stdin(serde_json::to_string(&event).unwrap())
        .output()
        .expect("command should run");

    assert_eq!(
        output.status.code(),
        Some(2),
        "Should block git push even when cwd is a symlink. stderr: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    evidence.pass("Symlink cwd resolution works — git push blocked via symlink", timer.elapsed_ms());
    let _ = evidence.save(&evidence_dir());

    drop(temp_dir);
    drop(symlink_dir);
}

/// Test 2: Canonical and symlink paths both resolve to same config.
#[test]
#[cfg(unix)]
fn test_symlink_vs_canonical_consistency() {
    use std::os::unix::fs::symlink;  // <-- import INSIDE function body (cfg-gated)

    let timer = Timer::start();
    let mut evidence = TestEvidence::new("e2e_symlink_vs_canonical", "E2E");

    let temp_dir = setup_test_env("block-all-push.yaml");
    let canonical_path = canonicalize_path(temp_dir.path());

    let symlink_dir = tempfile::tempdir().unwrap();
    let symlink_path = symlink_dir.path().join("link-to-project");
    symlink(temp_dir.path(), &symlink_path).expect("create symlink");

    let event_canonical = serde_json::json!({
        "hook_event_name": "PreToolUse",
        "tool_name": "Bash",
        "tool_input": { "command": "git push" },
        "cwd": canonical_path.to_string_lossy().to_string(),
        "session_id": "canonical-test"
    });

    let output_canonical = Command::cargo_bin("rulez")
        .expect("binary exists")
        .current_dir(temp_dir.path())
        .write_stdin(serde_json::to_string(&event_canonical).unwrap())
        .output()
        .expect("command should run");

    let event_symlink = serde_json::json!({
        "hook_event_name": "PreToolUse",
        "tool_name": "Bash",
        "tool_input": { "command": "git push" },
        "cwd": symlink_path.to_string_lossy().to_string(),
        "session_id": "symlink-test"
    });

    let output_symlink = Command::cargo_bin("rulez")
        .expect("binary exists")
        .current_dir(&symlink_path)
        .write_stdin(serde_json::to_string(&event_symlink).unwrap())
        .output()
        .expect("command should run");

    assert_eq!(output_canonical.status.code(), Some(2), "Canonical path should block git push");
    assert_eq!(output_symlink.status.code(), Some(2), "Symlink path should also block git push");

    evidence.pass("Both canonical and symlink paths produce same result (exit code 2)", timer.elapsed_ms());
    let _ = evidence.save(&evidence_dir());

    drop(temp_dir);
    drop(symlink_dir);
}

/// Test 3: Safe command allowed via symlink cwd.
#[test]
#[cfg(unix)]
fn test_symlink_cwd_allows_safe_commands() {
    use std::os::unix::fs::symlink;  // <-- import INSIDE function body (cfg-gated)

    let timer = Timer::start();
    let mut evidence = TestEvidence::new("e2e_symlink_safe_cmd", "E2E");

    let temp_dir = setup_test_env("block-all-push.yaml");

    let symlink_dir = tempfile::tempdir().unwrap();
    let symlink_path = symlink_dir.path().join("link-to-project");
    symlink(temp_dir.path(), &symlink_path).expect("create symlink");

    let cwd = symlink_path.to_string_lossy().to_string();
    let event = serde_json::json!({
        "hook_event_name": "PreToolUse",
        "tool_name": "Bash",
        "tool_input": { "command": "git status" },
        "cwd": cwd,
        "session_id": "symlink-safe-test"
    });

    let output = Command::cargo_bin("rulez")
        .expect("binary exists")
        .current_dir(&symlink_path)
        .write_stdin(serde_json::to_string(&event).unwrap())
        .output()
        .expect("command should run");

    assert!(output.status.success(), "Safe commands should be allowed via symlink cwd (exit 0)");

    evidence.pass("Safe command allowed via symlink cwd", timer.elapsed_ms());
    let _ = evidence.save(&evidence_dir());

    drop(temp_dir);
    drop(symlink_dir);
}
```

**Import strategy:** The `use std::os::unix::fs::symlink;` import is placed INSIDE each `#[cfg(unix)]` test function body. This avoids compilation errors on non-Unix platforms because:
- The top-level imports (`use assert_cmd::Command`, `use std::fs`, etc.) are cross-platform
- The Unix-specific `symlink` import only exists inside `#[cfg(unix)]` function bodies
- This matches the Rust pattern where `use` inside a function body is scoped to that function
- No `#[cfg(unix)]` attribute is needed at module level
  </action>
  <verify>
Run:
- `cargo test --workspace -- test_symlink` — all 3 symlink tests pass on macOS/Linux
- `cargo test --tests --all-features --workspace` — full suite passes (634+ tests now)
- `cargo clippy --all-targets --all-features --workspace -- -D warnings` — no warnings
  </verify>
  <done>
- 3 symlink resolution E2E tests exist (Unix-only)
- Tests verify blocked commands, allowed commands, and canonical vs symlink consistency
- All tests have explicit drop() for tempdir cleanup
  </done>
</task>

<task type="auto">
  <name>Task 2: Add explicit drop(temp_dir) to all existing E2E tests</name>
  <files>rulez/tests/e2e_git_push_block.rs</files>
  <action>
Add explicit `drop(temp_dir)` calls at the end of each E2E test function in `e2e_git_push_block.rs` to ensure deterministic cleanup. This prevents cleanup race conditions on Windows and CI.

**Tests to update (add `drop(temp_dir)` before the closing brace):**

1. `test_e2e_git_push_blocked_exit_code_2()` — add `drop(temp_dir);` after the `evidence.save()` call
2. `test_e2e_cwd_based_config_loading_exit_code_2()` — add `drop(temp_dir); drop(wrong_dir);` after `evidence.save()`
3. `test_e2e_git_status_allowed_exit_code_0()` — add `drop(temp_dir);` after `evidence.save()`
4. `test_e2e_git_push_variants_exit_code_2()` — The temp_dirs are created inside the loop and dropped at end of each iteration. No change needed (loop scope handles it).
5. `test_e2e_non_push_git_commands_exit_code_0()` — Same as #4, loop scope handles cleanup.
6. `test_e2e_output_format_claude_code_protocol()` — add `drop(temp_dir); drop(temp_dir2);` after `evidence.save()`
7. `test_e2e_no_config_allows_all()` — add `drop(empty_dir);` after `evidence.save()`
8. `test_e2e_cwd_git_push_variants_from_wrong_dir()` — add `drop(wrong_dir);` after `evidence.save()` (note: `_temp_dir` is already dropped by underscore prefix pattern inside the loop)

For tests #4 and #5 where temp_dirs are created inside for-loops, the loop scope already handles cleanup. However, consider that the loop creates many temp_dirs — if one iteration panics, cleanup of prior iterations' temp_dirs may not happen. This is acceptable since tempfile's Drop impl handles this.
  </action>
  <verify>
Run:
- `cargo test --workspace -- test_e2e` — all 8 E2E tests pass
- `cargo test --tests --all-features --workspace` — full suite passes
- `cargo clippy --all-targets --all-features --workspace -- -D warnings` — no warnings
  </verify>
  <done>
- All E2E tests with single temp_dir have explicit drop() calls
- Tests with multiple temp_dirs drop all of them
- Loop-scoped temp_dirs rely on scope drop (acceptable)
- No cleanup race conditions in CI
  </done>
</task>

</tasks>

<verification>
1. `cargo fmt --all --check` — no formatting issues
2. `cargo clippy --all-targets --all-features --workspace -- -D warnings` — no warnings
3. `cargo test --tests --all-features --workspace` — all 634+ tests pass (631 existing + 3 new symlink tests)
4. `cargo llvm-cov --all-features --workspace --no-report` — coverage run passes
5. Symlink tests are skipped on Windows (cfg(unix)) and pass on macOS/Linux
6. All E2E tests have explicit tempdir cleanup
</verification>

<success_criteria>
- 3 new symlink resolution E2E tests pass on macOS and Linux
- Symlink tests are correctly gated with #[cfg(unix)]
- All E2E tests have explicit drop(temp_dir) for deterministic cleanup
- All 634+ tests pass (631 existing + 3 new)
- No clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/09-e2e-test-stabilization/09-03-SUMMARY.md`
</output>
