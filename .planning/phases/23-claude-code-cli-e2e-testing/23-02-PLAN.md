---
phase: 23-claude-code-cli-e2e-testing
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - e2e/lib/claude_adapter.sh
  - e2e/fixtures/claude-code/hooks-deny.yaml
  - e2e/fixtures/claude-code/hooks-inject.yaml.template
  - e2e/fixtures/claude-code/hooks-hookfire.yaml
  - e2e/scenarios/claude-code/01-install.sh
  - e2e/scenarios/claude-code/02-hook-fire.sh
  - e2e/scenarios/claude-code/03-deny.sh
  - e2e/scenarios/claude-code/04-inject.sh
autonomous: true

must_haves:
  truths:
    - "`rulez install` creates a valid `.claude/settings.json` with hook entries in an isolated workspace"
    - "PreToolUse hook fires when Claude Code runs a Bash tool and RuleZ logs the event"
    - "A deny rule blocks a tool call, producing exit code 2 and an audit log entry with block action"
    - "An inject rule executes `inject_command` which writes a marker file to the workspace"
  artifacts:
    - path: "e2e/lib/claude_adapter.sh"
      provides: "Claude Code headless invocation helper and workspace config generator"
      min_lines: 40
    - path: "e2e/fixtures/claude-code/hooks-deny.yaml"
      provides: "RuleZ hooks.yaml with deny rule for git force push"
      contains: "block: true"
    - path: "e2e/fixtures/claude-code/hooks-inject.yaml.template"
      provides: "RuleZ hooks.yaml template with inject_command using __WORKSPACE__ placeholder"
      contains: "inject_command"
    - path: "e2e/fixtures/claude-code/hooks-hookfire.yaml"
      provides: "RuleZ hooks.yaml with a passthrough rule that logs PreToolUse events"
    - path: "e2e/scenarios/claude-code/01-install.sh"
      provides: "Install scenario: runs rulez install, asserts settings.json structure"
    - path: "e2e/scenarios/claude-code/02-hook-fire.sh"
      provides: "Hook fire scenario: invokes claude -p, asserts audit log entry"
    - path: "e2e/scenarios/claude-code/03-deny.sh"
      provides: "Deny scenario: invokes claude -p with force-push prompt, asserts block in log"
    - path: "e2e/scenarios/claude-code/04-inject.sh"
      provides: "Inject scenario: invokes claude -p, asserts marker file exists"
  key_links:
    - from: "e2e/scenarios/claude-code/*.sh"
      to: "e2e/lib/claude_adapter.sh"
      via: "source import (sourced by run.sh or scenario)"
      pattern: "invoke_claude_headless|setup_claude_hooks"
    - from: "e2e/scenarios/claude-code/03-deny.sh"
      to: "e2e/fixtures/claude-code/hooks-deny.yaml"
      via: "fixture file copy into workspace"
      pattern: "hooks-deny\\.yaml"
    - from: "e2e/scenarios/claude-code/04-inject.sh"
      to: "e2e/fixtures/claude-code/hooks-inject.yaml.template"
      via: "sed template substitution"
      pattern: "__WORKSPACE__"
---

<objective>
Create the Claude Code CLI adapter, test fixtures, and all 4 E2E scenarios (install, hook-fire, deny, inject).

Purpose: Validate that RuleZ integrates correctly with Claude Code CLI for the 4 core scenarios: install produces valid config, hooks fire and are logged, deny rules block tool calls, and inject rules add context via marker files.
Output: `e2e/lib/claude_adapter.sh`, fixture files under `e2e/fixtures/claude-code/`, 4 scenario scripts under `e2e/scenarios/claude-code/`.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-claude-code-cli-e2e-testing/23-RESEARCH.md
@.planning/phases/23-claude-code-cli-e2e-testing/23-01-SUMMARY.md
@e2e/lib/harness.sh
@e2e/lib/reporting.sh
@e2e/run.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Claude Code adapter library and fixture files</name>
  <files>e2e/lib/claude_adapter.sh, e2e/fixtures/claude-code/hooks-deny.yaml, e2e/fixtures/claude-code/hooks-inject.yaml.template, e2e/fixtures/claude-code/hooks-hookfire.yaml</files>
  <action>
**Create `e2e/lib/claude_adapter.sh`** (`#!/usr/bin/env bash`) with:

- `claude_adapter_check()` — Verifies `claude` is in PATH. Returns 1 with error message if not found. Prints version (`claude --version`) on success.

- `setup_claude_hooks(workspace, rulez_binary)` — Writes `$workspace/.claude/settings.json` with:
  ```json
  {
    "hooks": {
      "PreToolUse": [
        { "matcher": "*", "hooks": [{ "type": "command", "command": "<rulez_binary_abs_path>", "timeout": 10 }] }
      ]
    }
  }
  ```
  Uses absolute path for `rulez_binary`. This is the default settings.json used by scenarios 2-4 (scenarios copy their specific hooks.yaml into the workspace separately).

- `invoke_claude_headless(workspace, prompt, timeout_secs)` — Runs Claude Code in headless mode from the workspace directory:
  ```bash
  cd "$workspace" && timeout "${timeout_secs:-120}" claude \
    -p "$prompt" \
    --dangerously-skip-permissions \
    --output-format json \
    --max-turns 1 \
    --allowedTools "Bash" \
    --no-session-persistence \
    --model "claude-haiku-3-5" 2>&1
  ```
  Returns the exit code. Captures stdout+stderr to a file `$workspace/claude-output.txt` AND echoes it.

- `CLAUDE_CLI_NAME="claude-code"` — Constant for reporting.

**Create fixture files:**

`e2e/fixtures/claude-code/hooks-hookfire.yaml`:
```yaml
version: "1.0"
settings:
  log_level: "info"
  fail_open: true
rules:
  - name: e2e-hookfire-log
    description: "E2E test: logs PreToolUse event without blocking"
    matchers:
      tools: ["Bash"]
    actions:
      block: false
```

`e2e/fixtures/claude-code/hooks-deny.yaml`:
```yaml
version: "1.0"
settings:
  log_level: "info"
  fail_open: false
rules:
  - name: e2e-deny-force-push
    description: "E2E test: blocks git force push"
    matchers:
      tools: ["Bash"]
      command_match: "git push.*--force|git push.*-f"
    actions:
      block: true
```

`e2e/fixtures/claude-code/hooks-inject.yaml.template`:
```yaml
version: "1.0"
settings:
  log_level: "info"
  fail_open: true
rules:
  - name: e2e-inject-marker
    description: "E2E test: inject command writes marker file"
    matchers:
      tools: ["Bash"]
    actions:
      inject_command: "touch __WORKSPACE__/e2e-inject-fired.marker && echo 'E2E-INJECTED'"
```
Note: `__WORKSPACE__` is replaced at test setup time with the absolute workspace path using `sed`.
  </action>
  <verify>
`bash -n e2e/lib/claude_adapter.sh` exits 0.
`test -f e2e/fixtures/claude-code/hooks-deny.yaml` — deny fixture exists.
`test -f e2e/fixtures/claude-code/hooks-inject.yaml.template` — inject template exists.
`test -f e2e/fixtures/claude-code/hooks-hookfire.yaml` — hookfire fixture exists.
`grep -q 'block: true' e2e/fixtures/claude-code/hooks-deny.yaml` — deny rule present.
`grep -q '__WORKSPACE__' e2e/fixtures/claude-code/hooks-inject.yaml.template` — placeholder present.
  </verify>
  <done>
Claude adapter library provides headless invocation and workspace config helpers. Three fixture files define the RuleZ rules for hook-fire, deny, and inject scenarios with proper matchers and actions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create all 4 Claude Code E2E scenario scripts</name>
  <files>e2e/scenarios/claude-code/01-install.sh, e2e/scenarios/claude-code/02-hook-fire.sh, e2e/scenarios/claude-code/03-deny.sh, e2e/scenarios/claude-code/04-inject.sh</files>
  <action>
Each scenario script is sourced by `run.sh` and defines a `scenario_<name>` function that receives `(workspace, rulez_binary)` and returns 0 for pass, 1 for fail.

**Important:** Each scenario script should also source `claude_adapter.sh` (from `$E2E_ROOT/lib/claude_adapter.sh`) at the top for access to adapter functions.

**`e2e/scenarios/claude-code/01-install.sh`** — `scenario_install(workspace, rulez_binary)`:
1. Run `cd "$workspace" && "$rulez_binary" install --binary "$rulez_binary"` — captures exit code.
2. `assert_exit_code $exit_code 0 "rulez install exits 0"` — must succeed.
3. `assert_file_exists "$workspace/.claude/settings.json" "settings.json created"`.
4. `assert_file_contains "$workspace/.claude/settings.json" '"PreToolUse"' "settings.json contains PreToolUse hook"`.
5. `assert_file_contains "$workspace/.claude/settings.json" '"command"' "settings.json contains command entry"`.
6. Return 0 if all assertions pass, 1 if any fail. Track with a local `failures` counter.

**`e2e/scenarios/claude-code/02-hook-fire.sh`** — `scenario_hook_fire(workspace, rulez_binary)`:
1. Call `setup_claude_hooks "$workspace" "$rulez_binary"` to write settings.json.
2. Copy `$E2E_ROOT/fixtures/claude-code/hooks-hookfire.yaml` to `$workspace/.claude/hooks.yaml`.
3. Record log snapshot: `WORKSPACE_LOG_SNAPSHOT=$(wc -l < ~/.claude/logs/rulez.log 2>/dev/null || echo 0)`.
4. Call `invoke_claude_headless "$workspace" "Run this bash command: echo hello-e2e-hookfire" 120`.
5. `assert_log_contains "e2e-hookfire-log" "audit log contains hookfire rule name"` — verifies the PreToolUse hook fired and RuleZ logged the rule evaluation.
6. Return based on assertion results.

**`e2e/scenarios/claude-code/03-deny.sh`** — `scenario_deny(workspace, rulez_binary)`:
1. Call `setup_claude_hooks "$workspace" "$rulez_binary"`.
2. Copy `$E2E_ROOT/fixtures/claude-code/hooks-deny.yaml` to `$workspace/.claude/hooks.yaml`.
3. Record log snapshot.
4. Call `invoke_claude_headless "$workspace" "Run this exact bash command: git push --force origin main" 120`. Capture exit code (don't fail on non-zero — the deny IS the non-zero).
5. `assert_log_contains "e2e-deny-force-push" "audit log contains deny rule name"` — verifies the deny rule was evaluated.
6. `assert_log_contains "block" "audit log contains block action"` — verifies the block action was recorded.
7. Return based on assertion results. Note: Claude's exit code may be 0 even when a hook denies, because Claude handles hook denials internally. The proof is in the audit log, not Claude's exit code.

**`e2e/scenarios/claude-code/04-inject.sh`** — `scenario_inject(workspace, rulez_binary)`:
1. Call `setup_claude_hooks "$workspace" "$rulez_binary"`.
2. Generate hooks.yaml from template: `sed "s|__WORKSPACE__|${workspace}|g" "$E2E_ROOT/fixtures/claude-code/hooks-inject.yaml.template" > "$workspace/.claude/hooks.yaml"`. Use absolute path for workspace.
3. Record log snapshot.
4. Call `invoke_claude_headless "$workspace" "Run this bash command: echo hello-e2e-inject" 120`.
5. `assert_file_exists "$workspace/e2e-inject-fired.marker" "inject marker file created"` — the inject_command in the rule writes this marker file.
6. `assert_log_contains "e2e-inject-marker" "audit log contains inject rule name"`.
7. Return based on assertion results.

**Update `e2e/run.sh`** (if needed) to also source `e2e/lib/claude_adapter.sh` so it's available to scenarios, and to call `claude_adapter_check` before running claude-code scenarios (skip all claude-code scenarios with SKIP status if claude CLI is not found).

All scenario files should be `#!/usr/bin/env bash` but NOT have `set -e` (the harness controls error handling; individual assertion failures should not abort the scenario — collect all results).
  </action>
  <verify>
`bash -n e2e/scenarios/claude-code/01-install.sh` exits 0.
`bash -n e2e/scenarios/claude-code/02-hook-fire.sh` exits 0.
`bash -n e2e/scenarios/claude-code/03-deny.sh` exits 0.
`bash -n e2e/scenarios/claude-code/04-inject.sh` exits 0.
`grep -q 'scenario_install' e2e/scenarios/claude-code/01-install.sh` — function defined.
`grep -q 'scenario_hook_fire' e2e/scenarios/claude-code/02-hook-fire.sh` — function defined.
`grep -q 'scenario_deny' e2e/scenarios/claude-code/03-deny.sh` — function defined.
`grep -q 'scenario_inject' e2e/scenarios/claude-code/04-inject.sh` — function defined.
`grep -q 'invoke_claude_headless' e2e/scenarios/claude-code/02-hook-fire.sh` — uses adapter.
`grep -q 'assert_log_contains' e2e/scenarios/claude-code/03-deny.sh` — uses harness assertions.
`grep -q '__WORKSPACE__' e2e/scenarios/claude-code/04-inject.sh` — uses template substitution.
  </verify>
  <done>
All 4 Claude Code E2E scenarios exist, pass bash syntax check, use harness assertions (not text matching on agent output), and follow workspace isolation patterns. Install verifies structural config, hook-fire/deny/inject verify via audit log and marker files.
  </done>
</task>

</tasks>

<verification>
1. `bash -n e2e/lib/claude_adapter.sh && bash -n e2e/scenarios/claude-code/01-install.sh && bash -n e2e/scenarios/claude-code/02-hook-fire.sh && bash -n e2e/scenarios/claude-code/03-deny.sh && bash -n e2e/scenarios/claude-code/04-inject.sh` — all pass syntax check
2. `ls e2e/fixtures/claude-code/` — contains hooks-deny.yaml, hooks-inject.yaml.template, hooks-hookfire.yaml
3. `ls e2e/scenarios/claude-code/` — contains 01-install.sh through 04-inject.sh
4. Run `task e2e` (requires `claude` CLI and `ANTHROPIC_API_KEY`) — all 4 scenarios produce results (PASS/FAIL/SKIP) with JUnit XML and ASCII table output
5. `test -f e2e/.runs/*/junit.xml` — JUnit XML generated after a run
6. `test -f e2e/.runs/*/summary.md` — Markdown summary generated after a run
</verification>

<success_criteria>
- Claude adapter provides headless invocation with workspace isolation (project-level settings.json)
- 4 scenario scripts pass bash syntax validation
- All scenarios use deterministic proof artifacts (audit logs, marker files, structural assertions) — never assert on agent text output
- Install scenario verifies settings.json structure without invoking Claude CLI
- Hook-fire, deny, and inject scenarios invoke `claude -p` headlessly and verify via RuleZ audit log
- `task e2e` runs all scenarios end-to-end with JUnit XML + ASCII table + Markdown output
</success_criteria>

<output>
After completion, create `.planning/phases/23-claude-code-cli-e2e-testing/23-02-SUMMARY.md`
</output>
