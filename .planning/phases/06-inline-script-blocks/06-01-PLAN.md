---
phase: 06-inline-script-blocks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rulez/src/models.rs
  - rulez/src/config.rs
autonomous: true

must_haves:
  truths:
    - "validate_expr field exists on Actions struct and deserializes from YAML"
    - "inline_script field exists on Actions struct and deserializes from YAML"
    - "validate_expr and inline_script are mutually exclusive per rule (config validation rejects both)"
    - "validate_expr syntax is validated at config load time using build_operator_tree"
    - "inline_script validates non-empty content at config load time"
    - "Empty inline_script is rejected at config load time"
  artifacts:
    - path: "rulez/src/models.rs"
      provides: "validate_expr and inline_script fields on Actions struct"
      contains: "validate_expr"
    - path: "rulez/src/config.rs"
      provides: "Config validation for validate_expr syntax and inline_script structure"
      contains: "validate_expr"
  key_links:
    - from: "rulez/src/config.rs"
      to: "rulez/src/models.rs"
      via: "Config::validate reads rule.actions.validate_expr and rule.actions.inline_script"
      pattern: "rule\\.actions\\.validate_expr"
---

<objective>
Add validate_expr and inline_script fields to the Actions struct and implement config-time validation for both.

Purpose: Establish the data model and configuration validation for inline script blocks. This is the foundation that Plans 02 and 03 build upon.
Output: Actions struct with validate_expr/inline_script fields, config validation that rejects invalid expressions and empty scripts.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-inline-script-blocks/06-RESEARCH.md

Key prior patterns:
- Phase 5 added require_fields/field_types to Matchers; this adds validate_expr/inline_script to Actions
- Phase 3 established build_operator_tree for enabled_when syntax validation in config.rs
- Actions struct has inject, inject_inline, inject_command, run, block, block_if_match fields
- All new optional fields use #[serde(skip_serializing_if = "Option::is_none")]
- Config::validate() checks all rules in a loop; add new validation at the end of that loop
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add validate_expr and inline_script fields to Actions struct</name>
  <files>rulez/src/models.rs</files>
  <action>
Add two new fields to the Actions struct in models.rs:

1. `validate_expr: Option<String>` — An evalexpr expression that returns boolean. When present, the expression is evaluated at hook processing time. True = validation passes (allow), False = validation fails (block).

2. `inline_script: Option<String>` — A shell script written directly in YAML using literal block syntax (|). When present, the script is executed with event JSON on stdin. Exit code 0 = pass, non-zero = block.

Both fields should:
- Use `#[serde(skip_serializing_if = "Option::is_none")]` (consistent with all other optional Actions fields)
- Be placed AFTER the existing `block_if_match` field
- Have doc comments explaining their purpose and YAML usage

Also update ALL existing test struct instantiations in models.rs that construct Actions to include:
```rust
validate_expr: None,
inline_script: None,
```

This follows the established pattern from Phase 1 (inject_inline added to Actions) and Phase 5 (require_fields added to Matchers). Every test that constructs an Actions struct must be updated.

Note: The Actions struct currently has fields: inject, inject_inline, inject_command, run, block, block_if_match. The new fields go after block_if_match.
  </action>
  <verify>
`cd rulez && cargo build 2>&1` compiles without errors. All existing tests pass: `cargo test 2>&1 | tail -5` shows "test result: ok".
  </verify>
  <done>
Actions struct has validate_expr and inline_script fields. YAML like `validate_expr: 'has_field("name")'` and `inline_script: |` parse correctly via serde. All existing tests compile and pass with the new fields set to None.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add config-time validation for validate_expr and inline_script</name>
  <files>rulez/src/config.rs</files>
  <action>
Extend Config::validate() in config.rs to validate the new fields. Add validation AFTER the existing field_types validation block, before the closing `Ok(())`.

Three validations to add:

1. **validate_expr syntax validation** — If rule.actions.validate_expr is Some, use `build_operator_tree::<DefaultNumericTypes>(expr)` to check syntax (same pattern as enabled_when validation at line 143-150). Error message format:
   ```
   "Invalid validate_expr '{}' in rule '{}': syntax error"
   ```

2. **inline_script structure validation** — If rule.actions.inline_script is Some:
   - Reject empty/whitespace-only scripts: `script.trim().is_empty()` returns error:
     ```
     "Empty inline_script in rule '{}'"
     ```
   - Warn (tracing::warn, not error) if missing shebang: `!script.trim_start().starts_with("#!")`
     ```
     "inline_script in rule '{}' missing shebang - may not execute correctly"
     ```
   - Warn if script is very large (>10_000 bytes):
     ```
     "inline_script in rule '{}' is very large ({} bytes) - consider external file"
     ```

3. **Mutual exclusivity** — If BOTH validate_expr and inline_script are present on the same rule, return error:
   ```
   "Rule '{}' cannot have both validate_expr and inline_script - choose one"
   ```

Also update ALL existing test Actions struct instantiations in config.rs tests to include `validate_expr: None, inline_script: None,`.

Important: The mutual exclusivity check should run AFTER individual field validation (so both fields get syntax-checked even if they're mutually exclusive — better error messages).
  </action>
  <verify>
`cd rulez && cargo test 2>&1 | tail -5` shows all tests pass. Verify config validation works by checking existing config_validation tests still pass. The new validation integrates with the existing Config::validate() flow.
  </verify>
  <done>
Config::validate() rejects: (1) invalid evalexpr syntax in validate_expr, (2) empty inline_script content, (3) rules with both validate_expr and inline_script. Shebang and size warnings are logged but don't prevent loading. All existing tests pass with new None fields.
  </done>
</task>

</tasks>

<verification>
1. `cd rulez && cargo build` — compiles without errors or warnings
2. `cd rulez && cargo test` — all existing tests pass (no regressions)
3. YAML with validate_expr field parses correctly via serde_yaml
4. YAML with inline_script literal block parses correctly via serde_yaml
5. Config rejects validate_expr with invalid syntax
6. Config rejects empty inline_script
7. Config rejects rule with both validate_expr and inline_script
</verification>

<success_criteria>
- Actions struct has validate_expr and inline_script Option<String> fields
- Config validation catches invalid validate_expr syntax at load time
- Config validation catches empty inline_script at load time
- Config validation enforces mutual exclusivity of validate_expr and inline_script
- All 247+ existing tests pass without modification (only None fields added to test structs)
</success_criteria>

<output>
After completion, create `.planning/phases/06-inline-script-blocks/06-01-SUMMARY.md`
</output>
