---
phase: 06-inline-script-blocks
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - rulez/src/hooks.rs
autonomous: true

must_haves:
  truths:
    - "validate_expr evaluates expressions with get_field() and has_field() custom functions"
    - "get_field() returns field value from tool_input JSON using dot notation"
    - "has_field() returns boolean indicating field exists and is not null"
    - "validate_expr returning false blocks the operation (fail-closed)"
    - "validate_expr evaluation errors block the operation (fail-closed)"
    - "inline_script executes shell script with event JSON on stdin"
    - "inline_script exit code 0 allows, non-zero blocks"
    - "inline_script timeout causes blocking (fail-closed)"
    - "validate_expr/inline_script runs BEFORE inject actions in execute_rule_actions"
  artifacts:
    - path: "rulez/src/hooks.rs"
      provides: "build_eval_context_with_custom_functions, execute_inline_script, and modified execute_rule_actions"
      contains: "build_eval_context_with_custom_functions"
  key_links:
    - from: "rulez/src/hooks.rs:build_eval_context_with_custom_functions"
      to: "rulez/src/hooks.rs:build_eval_context"
      via: "Extends existing context with custom functions"
      pattern: "build_eval_context_with_custom_functions"
    - from: "rulez/src/hooks.rs:execute_rule_actions"
      to: "rulez/src/hooks.rs:execute_inline_script"
      via: "Called before inject actions when inline_script is present"
      pattern: "execute_inline_script"
    - from: "rulez/src/hooks.rs:build_eval_context_with_custom_functions"
      to: "rulez/src/models.rs:dot_to_pointer"
      via: "Custom functions use dot_to_pointer for field access"
      pattern: "dot_to_pointer"
---

<objective>
Implement the execution logic for validate_expr (with custom functions) and inline_script (with timeout protection), and integrate both into the rule action pipeline.

Purpose: This is the core runtime logic that makes inline script blocks actually work. Custom functions enable field inspection in expressions, inline script execution enables complex validation, and pipeline integration gates injection on validation success.
Output: Working validate_expr with get_field/has_field, working inline_script with timeout, both integrated into execute_rule_actions.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-inline-script-blocks/06-RESEARCH.md
@.planning/phases/06-inline-script-blocks/06-01-SUMMARY.md

Key prior patterns:
- build_eval_context (hooks.rs:360-385) creates evalexpr context with env vars, tool_name, event_type, prompt
- execute_inject_command (hooks.rs) uses tokio Command with timeout — same pattern for inline_script
- execute_validator_script uses tokio Command with stdin JSON — same stdin pattern for inline_script
- dot_to_pointer (models.rs) converts dot notation to JSON Pointer — reuse for get_field/has_field
- Fail-closed pattern: errors always block (never silently pass)
- execute_rule_actions (hooks.rs:765) handles inject/block actions — add validation BEFORE these
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement build_eval_context_with_custom_functions and execute_inline_script</name>
  <files>rulez/src/hooks.rs</files>
  <action>
Add two new functions to hooks.rs. Place them in a new section after the Field Validation section (after validate_required_fields) and before process_event.

**1. build_eval_context_with_custom_functions(event: &Event) -> HashMapContext<DefaultNumericTypes>**

Extends build_eval_context by adding two custom functions:

a) `get_field(path_string)` — Takes a dot-notation field path string, returns the field value from event.tool_input.
   - Clone event.tool_input into the closure (for 'static lifetime — see Research Pitfall 1)
   - Use dot_to_pointer to convert path to JSON Pointer
   - Type mapping:
     - JSON String -> evalexpr Value::String
     - JSON Number -> evalexpr Value::Float (use as_f64().unwrap_or(0.0))
     - JSON Bool -> evalexpr Value::Boolean
     - Missing/Null/Other -> evalexpr Value::String(String::new()) (empty string)
   - If tool_input is None, return empty string

b) `has_field(path_string)` — Takes a dot-notation field path string, returns boolean.
   - Clone event.tool_input into the closure
   - Use dot_to_pointer to convert path
   - Return true if field exists AND is not null
   - Return false if field is missing, null, or tool_input is None

Uses:
```rust
use evalexpr::{ContextWithMutableFunctions, Function};
use crate::models::dot_to_pointer;
```

Note: Function closures must be `move` closures that own cloned data. The pattern:
```rust
let tool_input_clone = event.tool_input.clone();
ctx.set_function("get_field".to_string(), Function::new(move |argument| {
    let path = argument.as_string()?;
    let pointer = dot_to_pointer(&path);
    // ... use tool_input_clone ...
}))?;
```

**2. execute_inline_script(script_content: &str, event: &Event, rule: &Rule, config: &Config) -> Result<bool>**

Executes an inline shell script with timeout protection. Pattern: follow execute_inject_command/execute_validator_script.

Steps:
1. Get timeout from rule.metadata.timeout or config.settings.script_timeout
2. Create temp file: `std::env::temp_dir().join(format!("rulez-inline-{}.sh", uuid::Uuid::new_v4()))`
   - NOTE: uuid may not be in dependencies. Use a simpler unique name approach: `format!("rulez-inline-{}-{}.sh", std::process::id(), std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_nanos())`
   - Or check if uuid is available in Cargo.toml; if not, use the timestamp approach
3. Write script_content to temp file using tokio::fs::write
4. Set permissions to 0o700 (Unix only, use cfg(unix))
5. Execute with `Command::new("sh").arg(&script_path)`
6. Pipe event JSON to stdin: serialize event with serde_json::to_string, write to child.stdin
7. Wait with timeout: `tokio::time::timeout(Duration::from_secs(timeout), child.wait_with_output())`
8. On timeout: warn + return Ok(false) (fail-closed — blocks operation)
9. On error: remove temp file + return Err
10. On success: remove temp file + return Ok(output.status.success())
11. CRITICAL: Clean up temp file on ALL exit paths (timeout, error, success)

Make the function `async` since it uses tokio Command.
  </action>
  <verify>
`cd rulez && cargo build 2>&1` compiles without errors. The new functions are syntactically correct and use proper types.
  </verify>
  <done>
build_eval_context_with_custom_functions creates an evalexpr context with get_field() and has_field() custom functions that inspect tool_input JSON. execute_inline_script runs a shell script with timeout and event JSON on stdin, returning bool for pass/fail.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate validate_expr and inline_script into execute_rule_actions pipeline</name>
  <files>rulez/src/hooks.rs</files>
  <action>
Modify execute_rule_actions (hooks.rs:765) and execute_rule_actions_warn_mode (hooks.rs:994) to run validation BEFORE existing block/inject logic.

**In execute_rule_actions (enforce mode):**

Add at the TOP of the function, BEFORE the existing block check (`if let Some(block) = actions.block`):

```rust
// Step 0: Run inline validation (if present) - gates all subsequent actions
if let Some(ref expr) = actions.validate_expr {
    let ctx = build_eval_context_with_custom_functions(event);
    match eval_boolean_with_context(expr, &ctx) {
        Ok(true) => {
            // Validation passed, continue to other actions
        }
        Ok(false) => {
            return Ok(Response::block(format!(
                "Validation failed for rule '{}': expression '{}' returned false",
                rule.name, expr
            )));
        }
        Err(e) => {
            // Expression error = fail-closed
            tracing::warn!(
                "validate_expr error for rule '{}': {} - blocking (fail-closed)",
                rule.name, e
            );
            return Ok(Response::block(format!(
                "Validation error for rule '{}': {}",
                rule.name, e
            )));
        }
    }
} else if let Some(ref script) = actions.inline_script {
    match execute_inline_script(script, event, rule, config).await {
        Ok(true) => {
            // Validation passed, continue
        }
        Ok(false) => {
            return Ok(Response::block(format!(
                "Inline script validation failed for rule '{}'",
                rule.name
            )));
        }
        Err(e) => {
            tracing::warn!(
                "inline_script error for rule '{}': {} - blocking (fail-closed)",
                rule.name, e
            );
            return Ok(Response::block(format!(
                "Inline script error for rule '{}': {}",
                rule.name, e
            )));
        }
    }
}
```

**In execute_rule_actions_warn_mode:**

Add similar logic at the TOP, but convert blocks to warnings:

```rust
if let Some(ref expr) = actions.validate_expr {
    let ctx = build_eval_context_with_custom_functions(event);
    match eval_boolean_with_context(expr, &ctx) {
        Ok(true) => { /* passed */ }
        Ok(false) => {
            let warning = format!(
                "[WARNING] Rule '{}' validation expression '{}' returned false.\n\
                 This rule is in 'warn' mode - operation will proceed.",
                rule.name, expr
            );
            return Ok(Response::inject(warning));
        }
        Err(e) => {
            let warning = format!(
                "[WARNING] Rule '{}' validation expression error: {}.\n\
                 This rule is in 'warn' mode - operation will proceed.",
                rule.name, e
            );
            return Ok(Response::inject(warning));
        }
    }
} else if let Some(ref script) = actions.inline_script {
    match execute_inline_script(script, event, rule, config).await {
        Ok(true) => { /* passed */ }
        Ok(false) => {
            let warning = format!(
                "[WARNING] Rule '{}' inline script validation failed.\n\
                 This rule is in 'warn' mode - operation will proceed.",
                rule.name
            );
            return Ok(Response::inject(warning));
        }
        Err(e) => {
            let warning = format!(
                "[WARNING] Rule '{}' inline script error: {}.\n\
                 This rule is in 'warn' mode - operation will proceed.",
                rule.name, e
            );
            return Ok(Response::inject(warning));
        }
    }
}
```

**Execution order after change:**
1. validate_expr / inline_script (NEW - validation gates)
2. block (existing)
3. block_if_match (existing)
4. inject_inline (existing)
5. inject_command (existing)
6. inject (existing)
7. run (existing)

This order ensures validation failure prevents any injection or further processing.
  </action>
  <verify>
`cd rulez && cargo build 2>&1` compiles without errors. `cd rulez && cargo test 2>&1 | tail -5` shows all existing tests pass (no regressions from pipeline changes).
  </verify>
  <done>
validate_expr and inline_script execute BEFORE all other actions. validate_expr uses custom functions (get_field, has_field) for field inspection. inline_script runs with timeout and stdin JSON. Both follow fail-closed pattern. Warn mode converts failures to warnings. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cd rulez && cargo build` — compiles without errors
2. `cd rulez && cargo test` — all existing 247+ tests pass (no regressions)
3. build_eval_context_with_custom_functions creates context with get_field and has_field functions
4. execute_inline_script handles timeout, stdin, temp file cleanup
5. execute_rule_actions runs validation before block/inject actions
6. Warn mode converts validation failures to warnings
</verification>

<success_criteria>
- build_eval_context_with_custom_functions extends evalexpr context with get_field() and has_field()
- get_field returns correct types: String for strings, Float for numbers, Boolean for bools, empty string for missing
- has_field returns true for existing non-null fields, false otherwise
- execute_inline_script writes script to temp file, executes with timeout, passes event JSON on stdin
- Timeout causes fail-closed blocking with warning log
- Temp files cleaned up on all exit paths
- validate_expr/inline_script execute BEFORE inject/block actions in pipeline
- Warn mode injects warnings instead of blocking
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/06-inline-script-blocks/06-02-SUMMARY.md`
</output>
