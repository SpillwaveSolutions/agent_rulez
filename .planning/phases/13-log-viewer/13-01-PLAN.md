# Phase 13 Plan 01: Rust Log Parsing Command + TypeScript Types + Tauri Wiring

## Wave
Wave 1 (can execute in parallel with Plan 02)

## Objective
Create the Rust Tauri command that reads and filters `~/.claude/logs/rulez.log` (JSON Lines), register new Tauri plugins (fs, dialog, clipboard), define the `LogEntryDto` TypeScript types, and add frontend Tauri invocation wrappers with mock fallbacks.

## Why This Plan Exists
Satisfies success criteria:
- **SC-1** (view audit log entries): Provides the data pipeline from log file to frontend
- **SC-2** (filter by text, severity, time range): Rust-side filtering for outcome/decision/time, plus text search support
- **SC-3** (100K+ entries at 60fps): Rust-side parsing ensures the renderer thread is never blocked by JSON Lines parsing

## Tasks

### Task 1: Add Tauri plugin dependencies and capabilities
**File(s):**
- `rulez_ui/src-tauri/Cargo.toml`
- `rulez_ui/src-tauri/src/main.rs`
- `rulez_ui/src-tauri/capabilities/default.json` (NEW)
- `rulez_ui/src-tauri/tauri.conf.json`

**Action:**
1. Add Rust dependencies to `Cargo.toml`:
   ```toml
   tauri-plugin-fs = "2"
   tauri-plugin-dialog = "2"
   tauri-plugin-clipboard-manager = "2"
   chrono = { version = "0.4", features = ["serde"] }
   ```
   Note: `chrono` is needed for timestamp parsing in the log command. `serde` and `serde_json` are already present.

2. Register plugins in `main.rs` by adding `.plugin(...)` calls before `.invoke_handler(...)`:
   ```rust
   .plugin(tauri_plugin_fs::init())
   .plugin(tauri_plugin_dialog::init())
   .plugin(tauri_plugin_clipboard_manager::init())
   ```

3. Create `rulez_ui/src-tauri/capabilities/default.json` with permissions for the plugins:
   ```json
   {
     "$schema": "../gen/schemas/desktop-schema.json",
     "identifier": "default",
     "description": "Default permissions for RuleZ UI",
     "windows": ["main"],
     "permissions": [
       "core:default",
       "shell:default",
       "store:default",
       "fs:default",
       "fs:allow-read-text-file",
       "fs:allow-write-text-file",
       "dialog:default",
       "dialog:allow-save",
       "clipboard-manager:default",
       "clipboard-manager:allow-write-text"
     ]
   }
   ```

4. Install frontend packages by running (from `rulez_ui/`):
   ```bash
   bun add @tanstack/react-virtual @tauri-apps/plugin-fs @tauri-apps/plugin-dialog @tauri-apps/plugin-clipboard-manager
   ```

**Acceptance:**
- `cd rulez_ui/src-tauri && cargo check` compiles without errors
- `package.json` shows the 4 new dependencies
- `capabilities/default.json` exists with correct permissions

### Task 2: Create Rust `logs` command module with `read_logs` and `get_log_stats`
**File(s):**
- `rulez_ui/src-tauri/src/commands/logs.rs` (NEW)
- `rulez_ui/src-tauri/src/commands/mod.rs`
- `rulez_ui/src-tauri/src/main.rs`

**Action:**
1. Create `logs.rs` with the following structures and commands:

   **Structs:**
   - `LogEntryDto` — flattened DTO with fields: `timestamp` (String), `event_type` (String), `session_id` (String), `tool_name` (Option<String>), `rules_matched` (Vec<String>), `outcome` (String — "allow"/"block"/"inject"), `processing_ms` (u64), `rules_evaluated` (usize), `decision` (Option<String>), `mode` (Option<String>), `priority` (Option<i32>), `response_continue` (Option<bool>), `response_reason` (Option<String>), `event_detail_command` (Option<String>), `event_detail_file_path` (Option<String>). All fields use `#[serde(rename_all = "camelCase")]` for JS convention.
   - `LogQueryParams` — filter input: `text_filter` (Option<String>), `outcome_filter` (Option<String>), `decision_filter` (Option<String>), `since` (Option<String> — RFC3339), `until` (Option<String> — RFC3339), `limit` (Option<usize>). Use `#[serde(rename_all = "camelCase")]`.
   - `LogStats` — stats: `total_entries` (usize), `file_size_bytes` (u64), `oldest_entry` (Option<String>), `newest_entry` (Option<String>). Use `#[serde(rename_all = "camelCase")]`.
   - `TimingDto` — embedded: `processing_ms` (u64), `rules_evaluated` (usize).

   **Commands:**
   - `#[tauri::command] pub async fn read_logs(params: LogQueryParams) -> Result<Vec<LogEntryDto>, String>`:
     - Get log path via `dirs::home_dir()` + `.claude/logs/rulez.log`
     - If file doesn't exist, return empty vec
     - Read file with `tokio::fs::read_to_string`
     - Parse each non-empty line as `serde_json::Value`
     - Convert each Value to `LogEntryDto` by extracting fields (handle missing fields gracefully with defaults)
     - For `event_detail_command`: extract from `event_details.command` when `event_details.tool_type == "Bash"`
     - For `event_detail_file_path`: extract from `event_details.file_path` for Write/Edit/Read tool types
     - Apply filters: `outcome_filter` checks `outcome` field, `decision_filter` checks `decision` field, `since`/`until` parse as RFC3339 and compare timestamps, `text_filter` does case-insensitive search across `event_type`, `tool_name`, `session_id`, `rules_matched`, `outcome`, `response_reason`, `event_detail_command`, `event_detail_file_path`
     - Skip malformed lines (log a warning, don't return error) — use `continue` on parse failure
     - Sort newest first by timestamp
     - Apply limit (default 10000 if not specified, to avoid IPC transfer issues)
     - Return filtered DTOs

   - `#[tauri::command] pub async fn get_log_stats() -> Result<LogStats, String>`:
     - Read log file, count lines, get file size via `tokio::fs::metadata`
     - Parse first and last lines for oldest/newest timestamps
     - Return stats

   **Helper:**
   - `fn get_log_path() -> PathBuf` — `dirs::home_dir()` + `.claude/logs/rulez.log`

2. Update `commands/mod.rs` to add `pub mod logs;`

3. Update `main.rs` to register the new commands in `invoke_handler`:
   ```rust
   use commands::{config, debug, logs};
   // ...
   .invoke_handler(tauri::generate_handler![
       config::list_config_files,
       config::read_config,
       config::write_config,
       debug::run_debug,
       debug::validate_config,
       logs::read_logs,
       logs::get_log_stats,
   ])
   ```

**Acceptance:**
- `cd rulez_ui/src-tauri && cargo check` compiles without errors
- `cargo test` passes (if any tests added)
- The `read_logs` and `get_log_stats` commands are registered in `main.rs`

### Task 3: Add TypeScript types and Tauri wrapper functions with mock data
**File(s):**
- `rulez_ui/src/types/index.ts`
- `rulez_ui/src/lib/tauri.ts`
- `rulez_ui/src/lib/mock-data.ts`

**Action:**
1. Add to `types/index.ts`:
   ```typescript
   // Log viewer types (Phase 13)
   export type Severity = "error" | "warn" | "info" | "debug";

   export interface LogEntryDto {
     timestamp: string;
     eventType: string;
     sessionId: string;
     toolName: string | null;
     rulesMatched: string[];
     outcome: "allow" | "block" | "inject";
     processingMs: number;
     rulesEvaluated: number;
     decision: "allowed" | "blocked" | "warned" | "audited" | null;
     mode: "enforce" | "warn" | "audit" | null;
     priority: number | null;
     responseContinue: boolean | null;
     responseReason: string | null;
     eventDetailCommand: string | null;
     eventDetailFilePath: string | null;
   }

   export interface LogQueryParams {
     textFilter?: string;
     outcomeFilter?: string;
     decisionFilter?: string;
     since?: string;
     until?: string;
     limit?: number;
   }

   export interface LogStats {
     totalEntries: number;
     fileSizeBytes: number;
     oldestEntry: string | null;
     newestEntry: string | null;
   }
   ```

2. Add `deriveSeverity` utility function (add to `types/index.ts` or a new `lib/log-utils.ts`):
   ```typescript
   export function deriveSeverity(entry: LogEntryDto): Severity {
     if (entry.outcome === "block" || entry.decision === "blocked") return "error";
     if (entry.decision === "warned" || entry.mode === "warn") return "warn";
     return "info";
   }
   ```

3. Add to `lib/tauri.ts` — two new exported functions following the existing `isTauri()` + mock pattern:
   - `readLogs(params: LogQueryParams): Promise<LogEntryDto[]>` — invokes `"read_logs"` with `{ params }`
   - `getLogStats(): Promise<LogStats>` — invokes `"get_log_stats"`
   - Each function has a mock fallback for browser testing mode

4. Add mock implementations in `lib/mock-data.ts` (or inline in `tauri.ts` matching existing pattern):
   - `mockReadLogs()` returns 50 sample entries with realistic data (mix of allow/block/inject outcomes, various event types and tool names, timestamps spread over the past 24 hours)
   - `mockGetLogStats()` returns `{ totalEntries: 14382, fileSizeBytes: 5200000, oldestEntry: <24h ago>, newestEntry: <now> }`

**Acceptance:**
- `cd rulez_ui && bun run typecheck` passes
- `readLogs` and `getLogStats` are exported from `lib/tauri.ts`
- Mock data returns realistic LogEntryDto objects in browser mode
- `deriveSeverity` function correctly maps outcomes to severity levels

## Verification
1. `cd rulez_ui/src-tauri && cargo check` — Rust compiles
2. `cd rulez_ui && bun run typecheck` — TypeScript compiles
3. `cd rulez_ui && bun run build` — Full frontend build succeeds
4. Manual: In browser mode (`bun run dev`), calling `readLogs({})` from console returns mock entries

## Dependencies
- Phase 12 must be complete (it is — ✅)
- No dependency on Plan 02 (can run in parallel)
