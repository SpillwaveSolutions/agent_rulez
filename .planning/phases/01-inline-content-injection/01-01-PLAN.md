---
phase: 01-inline-content-injection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rulez/src/models.rs
  - rulez/src/hooks.rs
  - rulez/tests/oq_us2_injection.rs
autonomous: true

must_haves:
  truths:
    - "YAML rules with inject_inline field parse successfully"
    - "Inline content is injected into response context"
    - "inject_inline takes precedence over inject when both specified"
    - "Multiline YAML strings (| and >) work correctly"
    - "Warn mode handles inject_inline identically to inject"
  artifacts:
    - path: "rulez/src/models.rs"
      provides: "Actions.inject_inline field"
      contains: "inject_inline: Option<String>"
    - path: "rulez/src/hooks.rs"
      provides: "inject_inline handling in execute_rule_actions"
      contains: "inject_inline"
    - path: "rulez/tests/oq_us2_injection.rs"
      provides: "Tests for inject_inline functionality"
      contains: "inject_inline"
  key_links:
    - from: "rulez/src/hooks.rs"
      to: "rulez/src/models.rs"
      via: "Actions.inject_inline field access"
      pattern: "actions\\.inject_inline"
---

<objective>
Implement the `inject_inline` action for the RuleZ rule engine.

Purpose: Allow users to embed markdown content directly in YAML rules without requiring separate context files. This simplifies single-file configurations and makes rule definitions more self-contained.

Output: Working inject_inline action with tests proving multiline YAML content injects into Claude's context correctly.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-inline-content-injection/01-RESEARCH.md
@rulez/src/models.rs
@rulez/src/hooks.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add inject_inline field and handling</name>
  <files>
    rulez/src/models.rs
    rulez/src/hooks.rs
  </files>
  <action>
    In models.rs, add `inject_inline: Option<String>` to the Actions struct (around line 274-301):
    - Add after the existing `inject` field
    - Include the serde skip_serializing_if attribute matching existing pattern
    - Add doc comment: "/// Inline markdown content to inject directly (no file read)"

    In hooks.rs, modify execute_rule_actions() (around line 337):
    - Add inject_inline handling BEFORE the existing inject handling (inject_inline takes precedence)
    - Pattern: `if let Some(ref inline_content) = actions.inject_inline { return Ok(Response::inject(inline_content.clone())); }`
    - No file I/O needed - content is already in memory

    In hooks.rs, modify execute_rule_actions_warn_mode() (around line 553):
    - Add same inject_inline handling before existing inject handling
    - Identical pattern - warn mode should treat inject_inline same as inject (no blocking behavior to convert)
  </action>
  <verify>
    cargo build --package rulez
    cargo test --package rulez -- models::governance_tests --nocapture
  </verify>
  <done>
    - models.rs has inject_inline field with proper serde attributes
    - hooks.rs handles inject_inline in both execute_rule_actions and execute_rule_actions_warn_mode
    - Code compiles without warnings
    - Existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add inject_inline tests</name>
  <files>
    rulez/src/models.rs
    rulez/tests/oq_us2_injection.rs
  </files>
  <action>
    In models.rs, add unit tests in the governance_tests module (or create new test module):

    1. test_inject_inline_literal_block - YAML literal block style (|):
       ```rust
       #[test]
       fn test_inject_inline_literal_block() {
           let yaml = r#"
inject_inline: |
  ## Production Warning
  You are editing production files.
  Be extra careful.
"#;
           let actions: Actions = serde_yaml::from_str(yaml).unwrap();
           let content = actions.inject_inline.unwrap();
           assert!(content.contains("## Production Warning"));
           assert!(content.contains("\n")); // Literal preserves newlines
       }
       ```

    2. test_inject_inline_folded_block - YAML folded block style (>):
       ```rust
       #[test]
       fn test_inject_inline_folded_block() {
           let yaml = r#"
inject_inline: >
  This is a long paragraph that
  will be folded into a single line.
"#;
           let actions: Actions = serde_yaml::from_str(yaml).unwrap();
           let content = actions.inject_inline.unwrap();
           assert!(content.contains("This is a long paragraph"));
       }
       ```

    3. test_inject_inline_simple_string - Quoted string style:
       ```rust
       #[test]
       fn test_inject_inline_simple_string() {
           let yaml = r#"inject_inline: "Single line warning""#;
           let actions: Actions = serde_yaml::from_str(yaml).unwrap();
           assert_eq!(actions.inject_inline.unwrap(), "Single line warning");
       }
       ```

    In tests/oq_us2_injection.rs, add an integration test:

    4. test_us2_inline_content_injection - Full rule with inject_inline:
       ```rust
       #[test]
       fn test_us2_inline_content_injection() {
           let timer = Timer::start();
           let mut evidence = TestEvidence::new("inline_content_injection", "OQ-US2");

           let temp_dir = tempfile::tempdir().expect("create temp dir");
           let claude_dir = temp_dir.path().join(".claude");
           fs::create_dir_all(&claude_dir).expect("create .claude");

           // Write config with inject_inline rule
           let config = r#"
version: "1.0"
rules:
  - name: inline-warning
    matchers:
      directories: ["/prod/"]
    actions:
      inject_inline: |
        ## Production Warning
        You are editing production files.
"#;
           fs::write(claude_dir.join("hooks.yaml"), config).expect("write config");

           // Event matching /prod/ directory
           let event = r#"{
               "event_type": "PreToolUse",
               "tool_name": "Edit",
               "tool_input": {
                   "filePath": "/prod/config.yaml",
                   "oldString": "old",
                   "newString": "new"
               },
               "session_id": "test-inline-inject",
               "timestamp": "2025-01-22T12:00:00Z"
           }"#;

           let result = Command::cargo_bin("rulez")  // or "cch" depending on binary name
               .expect("binary exists")
               .current_dir(temp_dir.path())
               .write_stdin(event)
               .assert()
               .success();

           // Response should allow and include inline context
           result.stdout(predicate::str::contains("continue").and(predicate::str::contains("true")));
           result.stdout(predicate::str::contains("Production Warning"));

           evidence.pass("Inline content correctly injected", timer.elapsed_ms());
           let _ = evidence.save(&evidence_dir());
       }
       ```
  </action>
  <verify>
    cargo test --package rulez -- inject_inline --nocapture
    cargo test --package rulez oq_us2 --nocapture
  </verify>
  <done>
    - Unit tests for literal block, folded block, and simple string parsing pass
    - Integration test verifies inject_inline content appears in response
    - All existing OQ-US2 tests still pass
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Build verification:
   ```bash
   cargo build --package rulez
   ```

2. Run all tests:
   ```bash
   cargo test --package rulez
   ```

3. Manual verification (optional):
   Create a test config with inject_inline and run rulez debug with a matching event.
</verification>

<success_criteria>
- inject_inline field exists in Actions struct with proper serde attributes
- inject_inline handling in execute_rule_actions returns Response::inject with content
- inject_inline handling in execute_rule_actions_warn_mode works identically
- All 3+ new unit tests pass (literal, folded, simple string)
- Integration test proves end-to-end injection works
- All existing tests pass (no regressions)
- cargo clippy reports no new warnings
</success_criteria>

<output>
After completion, create `.planning/phases/01-inline-content-injection/01-01-SUMMARY.md`
</output>
