---
phase: 03-conditional-rule-activation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - rulez/src/hooks.rs
autonomous: true

must_haves:
  truths:
    - "build_eval_context function creates context with env_*, tool_name, event_type"
    - "is_rule_enabled function evaluates enabled_when expression"
    - "Rules with false enabled_when are skipped in evaluate_rules loop"
    - "Rules with no enabled_when are always enabled"
    - "Invalid expressions disable rules (fail-closed)"
  artifacts:
    - path: "rulez/src/hooks.rs"
      provides: "build_eval_context and is_rule_enabled functions"
      contains: "is_rule_enabled"
  key_links:
    - from: "rulez/src/hooks.rs"
      to: "evalexpr"
      via: "eval_boolean_with_context"
      pattern: "eval_boolean_with_context"
    - from: "rulez/src/hooks.rs evaluate_rules"
      to: "is_rule_enabled"
      via: "early exit check before matches_rule"
      pattern: "is_rule_enabled.*continue"
---

<objective>
Implement expression evaluation functions and integrate into the rule evaluation loop.

Purpose: Make rules conditionally active based on enabled_when expressions evaluated against runtime context (environment variables, tool name, event type).

Output: Working enabled_when evaluation that skips rules when condition is false.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-conditional-rule-activation/03-RESEARCH.md
@.planning/phases/03-conditional-rule-activation/03-01-SUMMARY.md
@rulez/src/hooks.rs
@rulez/src/models.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement build_eval_context and is_rule_enabled functions</name>
  <files>rulez/src/hooks.rs</files>
  <action>
Add expression evaluation functions to hooks.rs:

1. Add evalexpr imports at the top of hooks.rs:
```rust
use evalexpr::{eval_boolean_with_context, HashMapContext, Value, DefaultNumericTypes};
```

2. Add build_eval_context function BEFORE evaluate_rules:
```rust
/// Build evaluation context for enabled_when expressions
fn build_eval_context(event: &Event) -> HashMapContext<DefaultNumericTypes> {
    let mut ctx = HashMapContext::new();

    // Add environment variables with env_ prefix
    for (key, value) in std::env::vars() {
        let var_name = format!("env_{}", key);
        ctx.set_value(var_name.into(), Value::String(value)).ok();
    }

    // Add tool name (empty string if none)
    let tool_name = event.tool_name.as_deref().unwrap_or("").to_string();
    ctx.set_value("tool_name".into(), Value::String(tool_name)).ok();

    // Add event type
    ctx.set_value(
        "event_type".into(),
        Value::String(event.hook_event_name.to_string())
    ).ok();

    ctx
}
```

3. Add is_rule_enabled function after build_eval_context:
```rust
/// Check if a rule is enabled based on its enabled_when expression
fn is_rule_enabled(rule: &Rule, event: &Event) -> bool {
    match &rule.enabled_when {
        None => true, // No condition = always enabled
        Some(expr) => {
            let ctx = build_eval_context(event);
            match eval_boolean_with_context(expr, &ctx) {
                Ok(result) => result,
                Err(e) => {
                    tracing::warn!(
                        "enabled_when expression failed for rule '{}': {} - treating as disabled",
                        rule.name, e
                    );
                    false // Fail-closed: invalid expression disables rule
                }
            }
        }
    }
}
```
  </action>
  <verify>
```bash
cd /Users/richardhightower/clients/spillwave/src/rulez_plugin/rulez && cargo build 2>&1 | tail -20
```
Build succeeds with no errors.
  </verify>
  <done>
- evalexpr imports added
- build_eval_context function creates context with env_*, tool_name, event_type
- is_rule_enabled function evaluates expressions with fail-closed semantics
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate is_rule_enabled into evaluate_rules loop and add tests</name>
  <files>rulez/src/hooks.rs</files>
  <action>
Integrate enabled_when check into the rule evaluation loop:

1. In evaluate_rules function, add is_rule_enabled check at the START of the for loop, BEFORE matches_rule:
```rust
    for rule in config.enabled_rules() {
        // NEW: Check enabled_when before matchers
        if !is_rule_enabled(rule, event) {
            if debug_config.enabled {
                rule_evaluations.push(RuleEvaluation {
                    rule_name: rule.name.clone(),
                    matched: false,
                    matcher_results: None,
                });
            }
            continue; // Skip rule entirely
        }
        // ... existing matches_rule logic
```

2. Add 5 unit tests for is_rule_enabled in the tests module:
- test_is_rule_enabled_no_condition
- test_is_rule_enabled_true_condition
- test_is_rule_enabled_false_condition
- test_is_rule_enabled_invalid_expression
- test_is_rule_enabled_tool_name_context

3. Update all existing test Rule instantiations to include `enabled_when: None`
  </action>
  <verify>
```bash
cd /Users/richardhightower/clients/spillwave/src/rulez_plugin/rulez && cargo test -- test_is_rule_enabled --nocapture 2>&1
```
All is_rule_enabled tests pass.
  </verify>
  <done>
- is_rule_enabled called before matches_rule in evaluate_rules loop
- Rules with false enabled_when are skipped
- 5 unit tests verify all scenarios
- All test Rule instantiations updated
  </done>
</task>

</tasks>

<verification>
Run all tests to verify no regressions:
```bash
cd /Users/richardhightower/clients/spillwave/src/rulez_plugin/rulez && cargo test 2>&1
```
Expected: All tests pass (210+), build succeeds.
</verification>

<success_criteria>
- build_eval_context creates context with all env vars, tool_name, event_type
- is_rule_enabled evaluates expressions correctly
- Invalid expressions disable rules (fail-closed)
- evaluate_rules skips rules when enabled_when is false
- 5 unit tests pass for is_rule_enabled
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/03-conditional-rule-activation/03-02-SUMMARY.md`
</output>
