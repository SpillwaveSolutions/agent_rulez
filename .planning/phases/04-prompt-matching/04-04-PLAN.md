---
phase: 04-prompt-matching
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - rulez/src/models.rs
  - rulez/src/hooks.rs
  - rulez/tests/prompt_match_integration.rs
autonomous: true

must_haves:
  truths:
    - "Unit tests verify PromptMatch YAML deserialization for all syntax variants"
    - "Unit tests verify pattern expansion (contains_word, not:)"
    - "Unit tests verify case-insensitive matching"
    - "Unit tests verify ANY vs ALL mode logic"
    - "Unit tests verify anchor positions"
    - "Integration tests verify end-to-end prompt matching in rule evaluation"
    - "All PROMPT-01 through PROMPT-05 requirements have test coverage"
    - "PROMPT-05: Tests verify prompt variable is accessible in evalexpr context for enabled_when scripts"
  artifacts:
    - path: "rulez/tests/prompt_match_integration.rs"
      provides: "Integration tests for prompt matching"
      contains: ["prompt_match", "#[tokio::test]"]
    - path: "rulez/src/models.rs"
      provides: "Unit tests for PromptMatch types"
      contains: ["prompt_match_tests"]
    - path: "rulez/src/hooks.rs"
      provides: "Unit tests for matches_prompt"
      contains: ["test_matches_prompt"]
  key_links:
    - from: "rulez/tests/prompt_match_integration.rs"
      to: "rulez/src/hooks.rs"
      via: "evaluate_rules"
      pattern: "process_event"
    - from: "rulez/src/hooks.rs"
      to: "evalexpr context"
      via: "build_eval_context sets prompt variable"
      pattern: 'set_value.*"prompt"'
      verification: "test_prompt_variable_available_in_evalexpr_context"
---

<objective>
Add comprehensive unit and integration tests for prompt matching.

Purpose: Verify all prompt matching requirements (PROMPT-01 through PROMPT-05) with thorough test coverage.
Output: Unit tests in models.rs and hooks.rs, integration tests in tests/prompt_match_integration.rs.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-prompt-matching/04-RESEARCH.md
@.planning/phases/04-prompt-matching/04-01-SUMMARY.md
@.planning/phases/04-prompt-matching/04-02-SUMMARY.md
@.planning/phases/04-prompt-matching/04-03-SUMMARY.md
@rulez/src/models.rs
@rulez/src/hooks.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PromptMatch unit tests in models.rs</name>
  <files>rulez/src/models.rs</files>
  <action>
Add a new test module for prompt matching types after the existing governance_tests module:

```rust
#[cfg(test)]
mod prompt_match_tests {
    use super::*;

    // =========================================================================
    // PromptMatch Deserialization Tests
    // =========================================================================

    #[test]
    fn test_prompt_match_simple_array_yaml() {
        let yaml = r#"["delete", "drop database"]"#;
        let pm: PromptMatch = serde_yaml::from_str(yaml).unwrap();

        match pm {
            PromptMatch::Simple(patterns) => {
                assert_eq!(patterns.len(), 2);
                assert_eq!(patterns[0], "delete");
                assert_eq!(patterns[1], "drop database");
            }
            _ => panic!("Expected Simple variant"),
        }
    }

    #[test]
    fn test_prompt_match_complex_object_yaml() {
        let yaml = r#"
patterns:
  - test
  - staging
mode: all
case_insensitive: true
anchor: start
"#;
        let pm: PromptMatch = serde_yaml::from_str(yaml).unwrap();

        match pm {
            PromptMatch::Complex { patterns, mode, case_insensitive, anchor } => {
                assert_eq!(patterns.len(), 2);
                assert_eq!(mode, MatchMode::All);
                assert!(case_insensitive);
                assert_eq!(anchor, Some(Anchor::Start));
            }
            _ => panic!("Expected Complex variant"),
        }
    }

    #[test]
    fn test_prompt_match_complex_defaults() {
        let yaml = r#"
patterns:
  - test
"#;
        let pm: PromptMatch = serde_yaml::from_str(yaml).unwrap();

        match pm {
            PromptMatch::Complex { patterns, mode, case_insensitive, anchor } => {
                assert_eq!(patterns.len(), 1);
                assert_eq!(mode, MatchMode::Any); // Default
                assert!(!case_insensitive); // Default
                assert!(anchor.is_none()); // Default
            }
            _ => panic!("Expected Complex variant"),
        }
    }

    // =========================================================================
    // PromptMatch Helper Method Tests
    // =========================================================================

    #[test]
    fn test_prompt_match_patterns_accessor() {
        let simple = PromptMatch::Simple(vec!["a".to_string(), "b".to_string()]);
        assert_eq!(simple.patterns(), &["a", "b"]);

        let complex = PromptMatch::Complex {
            patterns: vec!["c".to_string()],
            mode: MatchMode::All,
            case_insensitive: false,
            anchor: None,
        };
        assert_eq!(complex.patterns(), &["c"]);
    }

    #[test]
    fn test_prompt_match_mode_accessor() {
        let simple = PromptMatch::Simple(vec!["a".to_string()]);
        assert_eq!(simple.mode(), MatchMode::Any); // Default for Simple

        let complex_any = PromptMatch::Complex {
            patterns: vec!["a".to_string()],
            mode: MatchMode::Any,
            case_insensitive: false,
            anchor: None,
        };
        assert_eq!(complex_any.mode(), MatchMode::Any);

        let complex_all = PromptMatch::Complex {
            patterns: vec!["a".to_string()],
            mode: MatchMode::All,
            case_insensitive: false,
            anchor: None,
        };
        assert_eq!(complex_all.mode(), MatchMode::All);
    }

    // =========================================================================
    // Pattern Expansion Tests
    // =========================================================================

    #[test]
    fn test_expand_pattern_contains_word() {
        let expanded = PromptMatch::expand_pattern("contains_word:delete");
        assert_eq!(expanded, r"\bdelete\b");
    }

    #[test]
    fn test_expand_pattern_contains_word_with_spaces() {
        let expanded = PromptMatch::expand_pattern("contains_word: production ");
        assert_eq!(expanded, r"\bproduction\b");
    }

    #[test]
    fn test_expand_pattern_no_shorthand() {
        let expanded = PromptMatch::expand_pattern("regular pattern");
        assert_eq!(expanded, "regular pattern");
    }

    #[test]
    fn test_expand_pattern_regex_special_chars_escaped() {
        // contains_word should escape special regex chars
        let expanded = PromptMatch::expand_pattern("contains_word:test.file");
        assert_eq!(expanded, r"\btest\.file\b");
    }

    // =========================================================================
    // Anchor Application Tests
    // =========================================================================

    #[test]
    fn test_apply_anchor_start() {
        let anchored = PromptMatch::apply_anchor("pattern", Some(Anchor::Start));
        assert_eq!(anchored, "^pattern");
    }

    #[test]
    fn test_apply_anchor_end() {
        let anchored = PromptMatch::apply_anchor("pattern", Some(Anchor::End));
        assert_eq!(anchored, "pattern$");
    }

    #[test]
    fn test_apply_anchor_contains() {
        let anchored = PromptMatch::apply_anchor("pattern", Some(Anchor::Contains));
        assert_eq!(anchored, "pattern");
    }

    #[test]
    fn test_apply_anchor_none() {
        let anchored = PromptMatch::apply_anchor("pattern", None);
        assert_eq!(anchored, "pattern");
    }

    // =========================================================================
    // MatchMode Tests
    // =========================================================================

    #[test]
    fn test_match_mode_default() {
        let mode = MatchMode::default();
        assert_eq!(mode, MatchMode::Any);
    }

    #[test]
    fn test_match_mode_display() {
        assert_eq!(format!("{}", MatchMode::Any), "any");
        assert_eq!(format!("{}", MatchMode::All), "all");
    }

    #[test]
    fn test_match_mode_deserialize() {
        let any: MatchMode = serde_yaml::from_str("any").unwrap();
        let all: MatchMode = serde_yaml::from_str("all").unwrap();
        assert_eq!(any, MatchMode::Any);
        assert_eq!(all, MatchMode::All);
    }

    // =========================================================================
    // Anchor Tests
    // =========================================================================

    #[test]
    fn test_anchor_display() {
        assert_eq!(format!("{}", Anchor::Start), "start");
        assert_eq!(format!("{}", Anchor::End), "end");
        assert_eq!(format!("{}", Anchor::Contains), "contains");
    }

    #[test]
    fn test_anchor_deserialize() {
        let start: Anchor = serde_yaml::from_str("start").unwrap();
        let end: Anchor = serde_yaml::from_str("end").unwrap();
        let contains: Anchor = serde_yaml::from_str("contains").unwrap();
        assert_eq!(start, Anchor::Start);
        assert_eq!(end, Anchor::End);
        assert_eq!(contains, Anchor::Contains);
    }

    // =========================================================================
    // Full Rule YAML Parsing Tests
    // =========================================================================

    #[test]
    fn test_rule_with_simple_prompt_match_yaml() {
        let yaml = r#"
name: block-destructive
description: Block destructive prompts
matchers:
  operations: [UserPromptSubmit]
  prompt_match: ["delete all", "drop database"]
actions:
  block: true
"#;
        let rule: Rule = serde_yaml::from_str(yaml).unwrap();
        assert!(rule.matchers.prompt_match.is_some());
        let pm = rule.matchers.prompt_match.unwrap();
        assert_eq!(pm.patterns().len(), 2);
    }

    #[test]
    fn test_rule_with_complex_prompt_match_yaml() {
        let yaml = r#"
name: require-safety
description: Require both test and staging keywords
matchers:
  operations: [UserPromptSubmit]
  prompt_match:
    patterns: ["contains_word:test", "contains_word:staging"]
    mode: all
    case_insensitive: true
actions:
  inject_inline: "Safe environment detected"
"#;
        let rule: Rule = serde_yaml::from_str(yaml).unwrap();
        assert!(rule.matchers.prompt_match.is_some());
        let pm = rule.matchers.prompt_match.unwrap();
        assert_eq!(pm.mode(), MatchMode::All);
        assert!(pm.case_insensitive());
    }
}
```
  </action>
  <verify>cargo test --package rulez prompt_match -- --test-threads=1</verify>
  <done>PromptMatch unit tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Add matches_prompt unit tests in hooks.rs</name>
  <files>rulez/src/hooks.rs</files>
  <action>
Add tests to the existing tests module in hooks.rs:

```rust
    // =========================================================================
    // Phase 4: Prompt Matching Tests
    // =========================================================================

    #[test]
    fn test_matches_prompt_simple_any_match() {
        let pm = PromptMatch::Simple(vec![
            "delete".to_string(),
            "drop".to_string(),
        ]);

        // Should match if ANY pattern matches
        assert!(matches_prompt("please delete this file", &pm).unwrap());
        assert!(matches_prompt("drop the database", &pm).unwrap());
        assert!(!matches_prompt("create a new file", &pm).unwrap());
    }

    #[test]
    fn test_matches_prompt_complex_all_mode() {
        let pm = PromptMatch::Complex {
            patterns: vec!["test".to_string(), "staging".to_string()],
            mode: MatchMode::All,
            case_insensitive: false,
            anchor: None,
        };

        // Should match only if ALL patterns match
        assert!(matches_prompt("deploy to test and staging environments", &pm).unwrap());
        assert!(!matches_prompt("deploy to test only", &pm).unwrap());
        assert!(!matches_prompt("deploy to staging only", &pm).unwrap());
    }

    #[test]
    fn test_matches_prompt_case_insensitive() {
        let pm = PromptMatch::Complex {
            patterns: vec!["DELETE".to_string()],
            mode: MatchMode::Any,
            case_insensitive: true,
            anchor: None,
        };

        assert!(matches_prompt("delete this", &pm).unwrap());
        assert!(matches_prompt("DELETE this", &pm).unwrap());
        assert!(matches_prompt("Delete This", &pm).unwrap());
    }

    #[test]
    fn test_matches_prompt_case_sensitive_default() {
        let pm = PromptMatch::Simple(vec!["DELETE".to_string()]);

        assert!(matches_prompt("DELETE this", &pm).unwrap());
        assert!(!matches_prompt("delete this", &pm).unwrap());
    }

    #[test]
    fn test_matches_prompt_anchor_start() {
        let pm = PromptMatch::Complex {
            patterns: vec!["git push".to_string()],
            mode: MatchMode::Any,
            case_insensitive: false,
            anchor: Some(Anchor::Start),
        };

        assert!(matches_prompt("git push origin main", &pm).unwrap());
        assert!(!matches_prompt("please git push this", &pm).unwrap());
    }

    #[test]
    fn test_matches_prompt_anchor_end() {
        let pm = PromptMatch::Complex {
            patterns: vec!["--force".to_string()],
            mode: MatchMode::Any,
            case_insensitive: false,
            anchor: Some(Anchor::End),
        };

        assert!(matches_prompt("git push --force", &pm).unwrap());
        assert!(!matches_prompt("--force push now", &pm).unwrap());
    }

    #[test]
    fn test_matches_prompt_contains_word_shorthand() {
        let pm = PromptMatch::Simple(vec!["contains_word:delete".to_string()]);

        // Word boundary matching
        assert!(matches_prompt("please delete this", &pm).unwrap());
        assert!(matches_prompt("delete now", &pm).unwrap());
        assert!(!matches_prompt("undelete this", &pm).unwrap()); // Word boundary
    }

    #[test]
    fn test_matches_prompt_negation() {
        let pm = PromptMatch::Simple(vec!["not:review".to_string()]);

        // Should match when pattern is NOT found
        assert!(matches_prompt("deploy to production", &pm).unwrap());
        assert!(!matches_prompt("please review this", &pm).unwrap());
    }

    #[test]
    fn test_matches_prompt_negation_all_mode() {
        let pm = PromptMatch::Complex {
            patterns: vec![
                "not:review".to_string(),
                "not:approval".to_string(),
            ],
            mode: MatchMode::All,
            case_insensitive: false,
            anchor: None,
        };

        // Should match only if BOTH negations are true (neither word present)
        assert!(matches_prompt("deploy now", &pm).unwrap());
        assert!(!matches_prompt("needs review", &pm).unwrap());
        assert!(!matches_prompt("needs approval", &pm).unwrap());
        assert!(!matches_prompt("review and approval required", &pm).unwrap());
    }

    #[test]
    fn test_matches_prompt_empty_patterns() {
        let pm = PromptMatch::Simple(vec![]);
        assert!(!matches_prompt("any prompt", &pm).unwrap());
    }

    #[test]
    fn test_matches_prompt_invalid_regex_fails_gracefully() {
        let pm = PromptMatch::Simple(vec!["[invalid".to_string()]);
        // Should return false (fail-closed) with warning
        assert!(!matches_prompt("test", &pm).unwrap());
    }

    #[test]
    fn test_matches_rule_with_prompt_match_and_prompt() {
        let event = Event {
            hook_event_name: EventType::UserPromptSubmit,
            tool_name: None,
            tool_input: None,
            session_id: "test-session".to_string(),
            timestamp: Utc::now(),
            user_id: None,
            transcript_path: None,
            cwd: None,
            permission_mode: None,
            tool_use_id: None,
            prompt: Some("delete all files".to_string()),
        };

        let rule = Rule {
            name: "block-delete".to_string(),
            description: None,
            enabled_when: None,
            matchers: Matchers {
                tools: None,
                extensions: None,
                directories: None,
                operations: Some(vec!["UserPromptSubmit".to_string()]),
                command_match: None,
                prompt_match: Some(PromptMatch::Simple(vec!["delete".to_string()])),
            },
            actions: Actions {
                inject: None,
                inject_inline: None,
                inject_command: None,
                run: None,
                block: Some(true),
                block_if_match: None,
            },
            mode: None,
            priority: None,
            governance: None,
            metadata: None,
        };

        assert!(matches_rule(&event, &rule));
    }

    #[test]
    fn test_matches_rule_prompt_match_no_prompt_field() {
        // Event without prompt field should not match prompt_match rules
        let event = Event {
            hook_event_name: EventType::PreToolUse,
            tool_name: Some("Bash".to_string()),
            tool_input: None,
            session_id: "test-session".to_string(),
            timestamp: Utc::now(),
            user_id: None,
            transcript_path: None,
            cwd: None,
            permission_mode: None,
            tool_use_id: None,
            prompt: None, // No prompt
        };

        let rule = Rule {
            name: "prompt-rule".to_string(),
            description: None,
            enabled_when: None,
            matchers: Matchers {
                tools: None,
                extensions: None,
                directories: None,
                operations: None,
                command_match: None,
                prompt_match: Some(PromptMatch::Simple(vec!["test".to_string()])),
            },
            actions: Actions {
                inject: None,
                inject_inline: None,
                inject_command: None,
                run: None,
                block: Some(true),
                block_if_match: None,
            },
            mode: None,
            priority: None,
            governance: None,
            metadata: None,
        };

        // Should NOT match because event.prompt is None
        assert!(!matches_rule(&event, &rule));
    }

    // =========================================================================
    // PROMPT-05: Verify prompt variable available in evalexpr context
    // =========================================================================

    #[test]
    fn test_prompt_variable_available_in_evalexpr_context() {
        // This test verifies PROMPT-05: prompt variable wiring to evalexpr context
        // The build_eval_context function should expose event.prompt as "prompt" variable
        let event = Event {
            hook_event_name: EventType::UserPromptSubmit,
            tool_name: None,
            tool_input: None,
            session_id: "test-session".to_string(),
            timestamp: Utc::now(),
            user_id: None,
            transcript_path: None,
            cwd: None,
            permission_mode: None,
            tool_use_id: None,
            prompt: Some("deploy to production".to_string()),
        };

        // Build the evalexpr context from the event
        let ctx = build_eval_context(&event).expect("build_eval_context should succeed");

        // Verify prompt variable is accessible
        let prompt_value = ctx.get_value("prompt").expect("prompt variable should exist");
        assert_eq!(
            prompt_value,
            evalexpr::Value::String("deploy to production".to_string()),
            "prompt variable should contain the event.prompt text"
        );
    }

    #[test]
    fn test_prompt_variable_not_set_when_event_has_no_prompt() {
        // When event.prompt is None, the prompt variable should not be set
        let event = Event {
            hook_event_name: EventType::PreToolUse,
            tool_name: Some("Bash".to_string()),
            tool_input: None,
            session_id: "test-session".to_string(),
            timestamp: Utc::now(),
            user_id: None,
            transcript_path: None,
            cwd: None,
            permission_mode: None,
            tool_use_id: None,
            prompt: None,
        };

        let ctx = build_eval_context(&event).expect("build_eval_context should succeed");

        // prompt variable should NOT exist when event.prompt is None
        assert!(
            ctx.get_value("prompt").is_err(),
            "prompt variable should not exist when event.prompt is None"
        );
    }

    #[test]
    fn test_enabled_when_can_use_prompt_variable() {
        // Integration test: enabled_when expression can reference prompt variable
        // This tests PROMPT-05 end-to-end: evalexpr script accessing prompt
        use evalexpr::eval_boolean_with_context;

        let event = Event {
            hook_event_name: EventType::UserPromptSubmit,
            tool_name: None,
            tool_input: None,
            session_id: "test-session".to_string(),
            timestamp: Utc::now(),
            user_id: None,
            transcript_path: None,
            cwd: None,
            permission_mode: None,
            tool_use_id: None,
            prompt: Some("deploy to production".to_string()),
        };

        let ctx = build_eval_context(&event).expect("build_eval_context should succeed");

        // Test that enabled_when expressions can use the prompt variable
        // Example: enabled_when: 'str_contains(prompt, "production")'
        let result = eval_boolean_with_context(
            r#"str_contains(prompt, "production")"#,
            &ctx
        ).expect("eval should succeed");
        assert!(result, "prompt should contain 'production'");

        let result_false = eval_boolean_with_context(
            r#"str_contains(prompt, "staging")"#,
            &ctx
        ).expect("eval should succeed");
        assert!(!result_false, "prompt should not contain 'staging'");
    }
```
  </action>
  <verify>cargo test --package rulez matches_prompt -- --test-threads=1</verify>
  <done>matches_prompt unit tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Create integration test file</name>
  <files>rulez/tests/prompt_match_integration.rs</files>
  <action>
Create a new integration test file:

```rust
//! Integration tests for Phase 4: Prompt Matching
//!
//! Tests end-to-end prompt matching functionality with full config loading
//! and event processing.

use chrono::Utc;
use rulez::models::{Event, EventType, PromptMatch, MatchMode, Anchor};
use rulez::config::Config;

/// Helper to create a UserPromptSubmit event with prompt text
fn create_prompt_event(prompt: &str) -> Event {
    Event {
        hook_event_name: EventType::UserPromptSubmit,
        tool_name: None,
        tool_input: None,
        session_id: "integration-test".to_string(),
        timestamp: Utc::now(),
        user_id: None,
        transcript_path: None,
        cwd: None,
        permission_mode: None,
        tool_use_id: None,
        prompt: Some(prompt.to_string()),
    }
}

/// Helper to create config from YAML
fn config_from_yaml(yaml: &str) -> Config {
    serde_yaml::from_str(yaml).expect("Failed to parse YAML config")
}

#[test]
fn test_prompt_match_yaml_round_trip_simple() {
    let yaml = r#"
version: "1.0"
rules:
  - name: block-delete
    matchers:
      operations: [UserPromptSubmit]
      prompt_match: ["delete", "remove"]
    actions:
      block: true
"#;

    let config = config_from_yaml(yaml);
    assert!(config.validate().is_ok());

    let rule = &config.rules[0];
    let pm = rule.matchers.prompt_match.as_ref().unwrap();
    assert_eq!(pm.patterns().len(), 2);
    assert_eq!(pm.mode(), MatchMode::Any);
}

#[test]
fn test_prompt_match_yaml_round_trip_complex() {
    let yaml = r#"
version: "1.0"
rules:
  - name: require-safety
    matchers:
      operations: [UserPromptSubmit]
      prompt_match:
        patterns:
          - "contains_word:test"
          - "contains_word:staging"
        mode: all
        case_insensitive: true
        anchor: contains
    actions:
      inject_inline: "Safe environment"
"#;

    let config = config_from_yaml(yaml);
    assert!(config.validate().is_ok());

    let rule = &config.rules[0];
    let pm = rule.matchers.prompt_match.as_ref().unwrap();
    assert_eq!(pm.mode(), MatchMode::All);
    assert!(pm.case_insensitive());
    assert_eq!(pm.anchor(), Some(Anchor::Contains));
}

#[test]
fn test_prompt_match_with_negation_yaml() {
    let yaml = r#"
version: "1.0"
rules:
  - name: require-review
    matchers:
      operations: [UserPromptSubmit]
      prompt_match: ["not:review", "not:approval"]
    actions:
      block: true
"#;

    let config = config_from_yaml(yaml);
    assert!(config.validate().is_ok());
}

#[test]
fn test_prompt_match_combined_with_operations() {
    let yaml = r#"
version: "1.0"
rules:
  - name: user-prompt-only
    matchers:
      operations: [UserPromptSubmit]
      prompt_match: ["deploy"]
    actions:
      inject_inline: "Deployment detected"
"#;

    let config = config_from_yaml(yaml);
    assert!(config.validate().is_ok());

    // Rule has both operations and prompt_match
    let rule = &config.rules[0];
    assert!(rule.matchers.operations.is_some());
    assert!(rule.matchers.prompt_match.is_some());
}

#[test]
fn test_prompt_match_anchor_start_yaml() {
    let yaml = r#"
version: "1.0"
rules:
  - name: command-start
    matchers:
      operations: [UserPromptSubmit]
      prompt_match:
        patterns: ["git push", "npm publish"]
        anchor: start
    actions:
      inject: ".claude/deployment-checklist.md"
"#;

    let config = config_from_yaml(yaml);
    assert!(config.validate().is_ok());

    let pm = config.rules[0].matchers.prompt_match.as_ref().unwrap();
    assert_eq!(pm.anchor(), Some(Anchor::Start));
}

#[test]
fn test_invalid_prompt_match_rejected() {
    let yaml = r#"
version: "1.0"
rules:
  - name: invalid-regex
    matchers:
      prompt_match: ["[unclosed"]
    actions:
      block: true
"#;

    let config: Config = serde_yaml::from_str(yaml).unwrap();
    assert!(config.validate().is_err());
}

#[test]
fn test_empty_prompt_match_rejected() {
    let yaml = r#"
version: "1.0"
rules:
  - name: empty-patterns
    matchers:
      prompt_match: []
    actions:
      block: true
"#;

    let config: Config = serde_yaml::from_str(yaml).unwrap();
    assert!(config.validate().is_err());
}
```
  </action>
  <verify>cargo test --package rulez --test prompt_match_integration</verify>
  <done>Integration tests pass</done>
</task>

</tasks>

<verification>
1. `cargo test --package rulez` passes (all tests including new ones)
2. Test coverage for all PROMPT requirements:
   - PROMPT-01: Regex pattern matching (test_matches_prompt_simple_any_match)
   - PROMPT-02: Case-insensitive (test_matches_prompt_case_insensitive)
   - PROMPT-03: Multiple patterns with any/all (test_matches_prompt_complex_all_mode)
   - PROMPT-04: Anchor positions (test_matches_prompt_anchor_start/end)
   - PROMPT-05: Script-based via evalexpr context (prompt variable available)
3. Integration tests verify YAML parsing and validation
</verification>

<success_criteria>
- All new unit tests pass
- All new integration tests pass
- All 245+ existing tests continue to pass
- Test coverage addresses all PROMPT-01 through PROMPT-05 requirements
</success_criteria>

<output>
After completion, create `.planning/phases/04-prompt-matching/04-04-SUMMARY.md`
</output>
