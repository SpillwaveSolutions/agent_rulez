---
phase: 04-prompt-matching
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - rulez/src/config.rs
autonomous: true

must_haves:
  truths:
    - "Invalid regex patterns in prompt_match are rejected at config load time"
    - "Empty patterns array is rejected"
    - "Clear error messages indicate rule name and invalid pattern"
  artifacts:
    - path: "rulez/src/config.rs"
      provides: "prompt_match validation"
      contains: ["prompt_match", "validate"]
  key_links:
    - from: "rulez/src/config.rs"
      to: "Config::validate"
      via: "prompt_match validation"
      pattern: "prompt_match.*validate"
---

<objective>
Add validation for prompt_match patterns in config.rs.

Purpose: Catch invalid regex patterns and configuration errors at load time rather than runtime (PROMPT-01).
Output: Updated Config::validate function that validates prompt_match patterns.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-prompt-matching/04-RESEARCH.md
@.planning/phases/04-prompt-matching/04-01-SUMMARY.md
@rulez/src/config.rs
@rulez/src/models.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add prompt_match validation to Config::validate</name>
  <files>rulez/src/config.rs</files>
  <action>
1. Add import at the top of config.rs:
```rust
use crate::models::PromptMatch;
```

2. In the Config::validate method, add prompt_match validation after the enabled_when validation (around line 150):

```rust
            // Validate prompt_match patterns
            if let Some(ref prompt_match) = rule.matchers.prompt_match {
                let patterns = prompt_match.patterns();

                // Reject empty patterns array
                if patterns.is_empty() {
                    return Err(anyhow::anyhow!(
                        "Empty patterns array in prompt_match for rule '{}'",
                        rule.name
                    ));
                }

                // Validate each pattern is a valid regex
                for pattern in patterns {
                    // Extract actual pattern (handle negation and shorthands)
                    let effective_pattern = if let Some(inner) = pattern.strip_prefix("not:") {
                        inner.trim().to_string()
                    } else {
                        pattern.clone()
                    };

                    // Expand shorthands before validation
                    let expanded = PromptMatch::expand_pattern(&effective_pattern);

                    // Apply anchor for full pattern validation
                    let anchored = PromptMatch::apply_anchor(&expanded, prompt_match.anchor());

                    // Validate regex compiles
                    if let Err(e) = regex::Regex::new(&anchored) {
                        return Err(anyhow::anyhow!(
                            "Invalid regex pattern '{}' (expanded to '{}') in prompt_match for rule '{}': {}",
                            pattern, anchored, rule.name, e
                        ));
                    }
                }
            }
```
  </action>
  <verify>cargo check --package rulez</verify>
  <done>prompt_match validation compiles</done>
</task>

<task type="auto">
  <name>Task 2: Add validation unit tests</name>
  <files>rulez/src/config.rs</files>
  <action>
Add the following tests to the tests module in config.rs:

```rust
    // =========================================================================
    // Phase 4: prompt_match Validation Tests
    // =========================================================================

    #[test]
    fn test_prompt_match_valid_simple_array() {
        let config = Config {
            version: "1.0".to_string(),
            rules: vec![Rule {
                name: "valid-prompt".to_string(),
                description: None,
                enabled_when: None,
                matchers: crate::models::Matchers {
                    tools: None,
                    extensions: None,
                    directories: None,
                    operations: Some(vec!["UserPromptSubmit".to_string()]),
                    command_match: None,
                    prompt_match: Some(crate::models::PromptMatch::Simple(vec![
                        "delete".to_string(),
                        "drop database".to_string(),
                    ])),
                },
                actions: crate::models::Actions {
                    inject: None,
                    inject_inline: None,
                    inject_command: None,
                    run: None,
                    block: Some(true),
                    block_if_match: None,
                },
                mode: None,
                priority: None,
                governance: None,
                metadata: None,
            }],
            settings: Settings::default(),
        };

        assert!(config.validate().is_ok());
    }

    #[test]
    fn test_prompt_match_valid_complex_object() {
        let config = Config {
            version: "1.0".to_string(),
            rules: vec![Rule {
                name: "valid-prompt-complex".to_string(),
                description: None,
                enabled_when: None,
                matchers: crate::models::Matchers {
                    tools: None,
                    extensions: None,
                    directories: None,
                    operations: Some(vec!["UserPromptSubmit".to_string()]),
                    command_match: None,
                    prompt_match: Some(crate::models::PromptMatch::Complex {
                        patterns: vec!["test".to_string(), "staging".to_string()],
                        mode: crate::models::MatchMode::All,
                        case_insensitive: true,
                        anchor: Some(crate::models::Anchor::Contains),
                    }),
                },
                actions: crate::models::Actions {
                    inject: None,
                    inject_inline: None,
                    inject_command: None,
                    run: None,
                    block: Some(true),
                    block_if_match: None,
                },
                mode: None,
                priority: None,
                governance: None,
                metadata: None,
            }],
            settings: Settings::default(),
        };

        assert!(config.validate().is_ok());
    }

    #[test]
    fn test_prompt_match_empty_patterns_rejected() {
        let config = Config {
            version: "1.0".to_string(),
            rules: vec![Rule {
                name: "empty-patterns".to_string(),
                description: None,
                enabled_when: None,
                matchers: crate::models::Matchers {
                    tools: None,
                    extensions: None,
                    directories: None,
                    operations: None,
                    command_match: None,
                    prompt_match: Some(crate::models::PromptMatch::Simple(vec![])),
                },
                actions: crate::models::Actions {
                    inject: None,
                    inject_inline: None,
                    inject_command: None,
                    run: None,
                    block: Some(true),
                    block_if_match: None,
                },
                mode: None,
                priority: None,
                governance: None,
                metadata: None,
            }],
            settings: Settings::default(),
        };

        let result = config.validate();
        assert!(result.is_err());
        let err_msg = result.unwrap_err().to_string();
        assert!(err_msg.contains("Empty patterns"));
        assert!(err_msg.contains("empty-patterns"));
    }

    #[test]
    fn test_prompt_match_invalid_regex_rejected() {
        let config = Config {
            version: "1.0".to_string(),
            rules: vec![Rule {
                name: "invalid-regex".to_string(),
                description: None,
                enabled_when: None,
                matchers: crate::models::Matchers {
                    tools: None,
                    extensions: None,
                    directories: None,
                    operations: None,
                    command_match: None,
                    prompt_match: Some(crate::models::PromptMatch::Simple(vec![
                        "[invalid(regex".to_string(), // Unclosed brackets
                    ])),
                },
                actions: crate::models::Actions {
                    inject: None,
                    inject_inline: None,
                    inject_command: None,
                    run: None,
                    block: Some(true),
                    block_if_match: None,
                },
                mode: None,
                priority: None,
                governance: None,
                metadata: None,
            }],
            settings: Settings::default(),
        };

        let result = config.validate();
        assert!(result.is_err());
        let err_msg = result.unwrap_err().to_string();
        assert!(err_msg.contains("Invalid regex pattern"));
        assert!(err_msg.contains("invalid-regex"));
    }

    #[test]
    fn test_prompt_match_shorthand_valid() {
        let config = Config {
            version: "1.0".to_string(),
            rules: vec![Rule {
                name: "shorthand-valid".to_string(),
                description: None,
                enabled_when: None,
                matchers: crate::models::Matchers {
                    tools: None,
                    extensions: None,
                    directories: None,
                    operations: None,
                    command_match: None,
                    prompt_match: Some(crate::models::PromptMatch::Simple(vec![
                        "contains_word:delete".to_string(),
                        "not:review".to_string(),
                    ])),
                },
                actions: crate::models::Actions {
                    inject: None,
                    inject_inline: None,
                    inject_command: None,
                    run: None,
                    block: Some(true),
                    block_if_match: None,
                },
                mode: None,
                priority: None,
                governance: None,
                metadata: None,
            }],
            settings: Settings::default(),
        };

        assert!(config.validate().is_ok());
    }
```
  </action>
  <verify>cargo test --package rulez config -- --test-threads=1</verify>
  <done>Validation tests pass</done>
</task>

</tasks>

<verification>
1. `cargo check --package rulez` passes
2. `cargo test --package rulez` passes (all tests including new validation tests)
3. Invalid regex patterns rejected with clear error message
4. Empty patterns array rejected
</verification>

<success_criteria>
- Config validation catches invalid prompt_match patterns at load time
- Error messages clearly indicate the rule name and problematic pattern
- Shorthands (contains_word:, not:) are validated correctly
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-prompt-matching/04-03-SUMMARY.md`
</output>
