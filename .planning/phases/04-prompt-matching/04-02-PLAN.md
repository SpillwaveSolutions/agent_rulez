---
phase: 04-prompt-matching
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - rulez/src/hooks.rs
  - rulez/src/models.rs
autonomous: true

must_haves:
  truths:
    - "Rules with prompt_match match against event.prompt text"
    - "Missing prompt field in event causes prompt_match rule to not match"
    - "Case-insensitive matching works when case_insensitive: true"
    - "ANY mode matches if any pattern matches"
    - "ALL mode requires all patterns to match"
    - "Anchor positions apply correctly (start, end, contains)"
    - "Shorthand patterns expand correctly (contains_word)"
    - "Negation patterns work (not:)"
    - "Prompt variable available in evalexpr context"
  artifacts:
    - path: "rulez/src/hooks.rs"
      provides: "matches_prompt function, regex caching"
      contains: ["fn matches_prompt", "REGEX_CACHE"]
  key_links:
    - from: "rulez/src/hooks.rs"
      to: "matches_rule function"
      via: "prompt_match check"
      pattern: "matchers.prompt_match"
---

<objective>
Implement prompt matching logic in hooks.rs with regex caching.

Purpose: Enable rule evaluation against prompt text (PROMPT-01 through PROMPT-05).
Output: matches_prompt function, regex caching with once_cell, prompt variable in evalexpr context.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-prompt-matching/04-RESEARCH.md
@.planning/phases/04-prompt-matching/04-01-SUMMARY.md
@rulez/src/hooks.rs
@rulez/src/models.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add regex caching infrastructure</name>
  <files>rulez/src/hooks.rs</files>
  <action>
Add at the top of hooks.rs (after the existing imports):

```rust
use once_cell::sync::Lazy;
use std::collections::HashMap;
use std::sync::Mutex;
use regex::RegexBuilder;

use crate::models::{PromptMatch, MatchMode, Anchor};

// =============================================================================
// Regex Caching for Performance
// =============================================================================

/// Global cache for compiled regex patterns
/// Key format: "pattern:case_insensitive" (e.g., "foo:true" or "bar:false")
static REGEX_CACHE: Lazy<Mutex<HashMap<String, Regex>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));

/// Get or compile a regex pattern with caching
fn get_or_compile_regex(pattern: &str, case_insensitive: bool) -> Result<Regex> {
    let cache_key = format!("{}:{}", pattern, case_insensitive);

    // Try to get from cache
    {
        let cache = REGEX_CACHE.lock().unwrap();
        if let Some(regex) = cache.get(&cache_key) {
            return Ok(regex.clone());
        }
    }

    // Compile and cache
    let regex = if case_insensitive {
        RegexBuilder::new(pattern)
            .case_insensitive(true)
            .build()
            .with_context(|| format!("Invalid regex pattern: {}", pattern))?
    } else {
        Regex::new(pattern)
            .with_context(|| format!("Invalid regex pattern: {}", pattern))?
    };

    let mut cache = REGEX_CACHE.lock().unwrap();
    cache.insert(cache_key, regex.clone());
    Ok(regex)
}
```

Also add the necessary imports at the top if not already present:
- `use anyhow::Context;` (if not already imported)
  </action>
  <verify>cargo check --package rulez</verify>
  <done>Regex caching infrastructure compiles</done>
</task>

<task type="auto">
  <name>Task 2: Implement matches_prompt function</name>
  <files>rulez/src/hooks.rs</files>
  <action>
Add the matches_prompt function after the regex caching code:

```rust
// =============================================================================
// Prompt Pattern Matching (Phase 4)
// =============================================================================

/// Check if prompt text matches the given PromptMatch configuration
///
/// Handles:
/// - Simple array syntax (ANY mode, case-sensitive)
/// - Complex object syntax with mode, case_insensitive, anchor
/// - Shorthand expansion (contains_word:, not:)
/// - Negation patterns
fn matches_prompt(prompt: &str, prompt_match: &PromptMatch) -> Result<bool> {
    let patterns = prompt_match.patterns();
    let mode = prompt_match.mode();
    let case_insensitive = prompt_match.case_insensitive();
    let anchor = prompt_match.anchor();

    if patterns.is_empty() {
        return Ok(false);
    }

    let mut results = Vec::with_capacity(patterns.len());

    for pattern in patterns {
        // Check for negation prefix
        let (is_negated, effective_pattern) = if let Some(inner) = pattern.strip_prefix("not:") {
            (true, inner.trim().to_string())
        } else {
            (false, pattern.clone())
        };

        // Expand shorthand patterns
        let expanded = PromptMatch::expand_pattern(&effective_pattern);

        // Apply anchor
        let anchored = PromptMatch::apply_anchor(&expanded, anchor);

        // Compile and match
        match get_or_compile_regex(&anchored, case_insensitive) {
            Ok(regex) => {
                let matched = regex.is_match(prompt);
                // Apply negation
                let result = if is_negated { !matched } else { matched };
                results.push(result);
            }
            Err(e) => {
                // Log warning and treat as non-match (fail-closed)
                tracing::warn!(
                    "Invalid prompt_match pattern '{}': {} - treating as non-match",
                    pattern, e
                );
                results.push(false);
            }
        }
    }

    // Apply match mode
    match mode {
        MatchMode::Any => Ok(results.iter().any(|&r| r)),
        MatchMode::All => Ok(results.iter().all(|&r| r)),
    }
}
```
  </action>
  <verify>cargo check --package rulez</verify>
  <done>matches_prompt function compiles</done>
</task>

<task type="auto">
  <name>Task 3: Integrate prompt matching into matches_rule and update build_eval_context</name>
  <files>rulez/src/hooks.rs</files>
  <action>
1. In the `matches_rule` function, add prompt_match check after the operations check (around line 300):

```rust
    // Check prompt patterns (for UserPromptSubmit events)
    if let Some(ref prompt_match) = matchers.prompt_match {
        // If rule has prompt_match but event has no prompt, rule doesn't match
        if let Some(ref prompt_text) = event.prompt {
            match matches_prompt(prompt_text, prompt_match) {
                Ok(true) => { /* Pattern matched, continue checking other matchers */ }
                Ok(false) => return false,
                Err(e) => {
                    tracing::warn!(
                        "prompt_match evaluation failed: {} - treating as non-match",
                        e
                    );
                    return false;
                }
            }
        } else {
            // No prompt field in event - rule doesn't match (safe default)
            return false;
        }
    }
```

2. In the `matches_rule_with_debug` function, add corresponding prompt_match check and add `prompt_match_matched` tracking to MatcherResults:

First, update MatcherResults in models.rs to add:
```rust
    /// Whether prompt_match regex matched
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prompt_match_matched: Option<bool>,
```

Then add to matches_rule_with_debug after operations check:
```rust
    // Check prompt patterns
    if let Some(ref prompt_match) = matchers.prompt_match {
        matcher_results.prompt_match_matched = Some(
            if let Some(ref prompt_text) = event.prompt {
                matches_prompt(prompt_text, prompt_match).unwrap_or(false)
            } else {
                false
            }
        );
        if !matcher_results.prompt_match_matched.unwrap() {
            overall_match = false;
        }
    }
```

3. In the `build_eval_context` function, add prompt variable after event_type (around line 143):

```rust
    // Add prompt text (if available - primarily for UserPromptSubmit events)
    if let Some(ref prompt) = event.prompt {
        ctx.set_value("prompt".into(), Value::String(prompt.clone())).ok();
    }
```
  </action>
  <verify>cargo test --package rulez -- --test-threads=1</verify>
  <done>Prompt matching integrated into rule evaluation, all existing tests pass</done>
</task>

</tasks>

<verification>
1. `cargo check --package rulez` passes
2. `cargo test --package rulez` passes (all existing tests)
3. Manual verification in debug mode shows prompt_match_matched in output
</verification>

<success_criteria>
- Rules with prompt_match evaluate against event.prompt
- Missing prompt causes prompt_match rules to not match (safe default)
- Regex caching prevents recompilation
- All existing 245+ tests continue to pass
- No performance regression (sub-10ms requirement maintained)
</success_criteria>

<output>
After completion, create `.planning/phases/04-prompt-matching/04-02-SUMMARY.md`
</output>
