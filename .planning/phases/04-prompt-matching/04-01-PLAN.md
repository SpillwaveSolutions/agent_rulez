---
phase: 04-prompt-matching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rulez/src/models.rs
autonomous: true

must_haves:
  truths:
    - "PromptMatch enum deserializes from simple array syntax"
    - "PromptMatch enum deserializes from complex object syntax with mode, case_insensitive, anchor"
    - "Matchers struct includes prompt_match field"
    - "Event struct includes prompt field for UserPromptSubmit events"
    - "MatchMode enum has Any and All variants"
    - "Anchor enum has Start, End, Contains variants"
  artifacts:
    - path: "rulez/src/models.rs"
      provides: "PromptMatch, MatchMode, Anchor types"
      contains: ["enum PromptMatch", "enum MatchMode", "enum Anchor"]
  key_links:
    - from: "rulez/src/models.rs"
      to: "Matchers struct"
      via: "prompt_match field"
      pattern: "pub prompt_match: Option<PromptMatch>"
---

<objective>
Add core type definitions for prompt matching to models.rs.

Purpose: Enable users to match rules against prompt text patterns using flexible YAML syntax (PROMPT-01, PROMPT-02, PROMPT-03, PROMPT-04).
Output: PromptMatch enum with serde deserialization, supporting types (MatchMode, Anchor), and updated Matchers/Event structs.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-prompt-matching/04-RESEARCH.md
@rulez/src/models.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MatchMode and Anchor enums</name>
  <files>rulez/src/models.rs</files>
  <action>
Add the following enums after the TrustLevel definition (around line 127):

```rust
// =============================================================================
// Phase 4: Prompt Matching Types
// =============================================================================

/// Pattern matching mode for multiple prompt patterns
#[derive(Debug, Clone, Copy, Default, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum MatchMode {
    /// Match if ANY pattern matches (OR logic) - default
    #[default]
    Any,
    /// Match if ALL patterns match (AND logic)
    All,
}

impl std::fmt::Display for MatchMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MatchMode::Any => write!(f, "any"),
            MatchMode::All => write!(f, "all"),
        }
    }
}

/// Anchor position for prompt pattern matching
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum Anchor {
    /// Pattern must match at start of prompt (^ prefix)
    Start,
    /// Pattern must match at end of prompt ($ suffix)
    End,
    /// Pattern can match anywhere in prompt (default)
    Contains,
}

impl std::fmt::Display for Anchor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Anchor::Start => write!(f, "start"),
            Anchor::End => write!(f, "end"),
            Anchor::Contains => write!(f, "contains"),
        }
    }
}
```
  </action>
  <verify>cargo check --package rulez</verify>
  <done>MatchMode and Anchor enums compile without errors</done>
</task>

<task type="auto">
  <name>Task 2: Add PromptMatch enum with serde untagged</name>
  <files>rulez/src/models.rs</files>
  <action>
Add the PromptMatch enum after the Anchor definition:

```rust
/// Prompt text pattern matching configuration
///
/// Supports two YAML formats:
/// ```yaml
/// # Simple array syntax (ANY mode, case-sensitive)
/// prompt_match: ["pattern1", "pattern2"]
///
/// # Complex object syntax with options
/// prompt_match:
///   patterns: ["pattern1", "pattern2"]
///   mode: all
///   case_insensitive: true
///   anchor: start
/// ```
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(untagged)]
pub enum PromptMatch {
    /// Simple array syntax: ["pattern1", "pattern2"]
    /// Uses ANY mode and case-sensitive matching
    Simple(Vec<String>),

    /// Complex object syntax with options
    Complex {
        /// Patterns to match against prompt text
        patterns: Vec<String>,
        /// Match mode: any (OR) or all (AND)
        #[serde(default)]
        mode: MatchMode,
        /// Enable case-insensitive matching
        #[serde(default)]
        case_insensitive: bool,
        /// Anchor position for patterns
        #[serde(skip_serializing_if = "Option::is_none")]
        anchor: Option<Anchor>,
    },
}

impl PromptMatch {
    /// Get patterns regardless of variant
    pub fn patterns(&self) -> &[String] {
        match self {
            PromptMatch::Simple(patterns) => patterns,
            PromptMatch::Complex { patterns, .. } => patterns,
        }
    }

    /// Get match mode (defaults to Any for Simple variant)
    pub fn mode(&self) -> MatchMode {
        match self {
            PromptMatch::Simple(_) => MatchMode::Any,
            PromptMatch::Complex { mode, .. } => *mode,
        }
    }

    /// Get case sensitivity setting (defaults to false for Simple variant)
    pub fn case_insensitive(&self) -> bool {
        match self {
            PromptMatch::Simple(_) => false,
            PromptMatch::Complex { case_insensitive, .. } => *case_insensitive,
        }
    }

    /// Get anchor setting (defaults to None/Contains for Simple variant)
    pub fn anchor(&self) -> Option<Anchor> {
        match self {
            PromptMatch::Simple(_) => None,
            PromptMatch::Complex { anchor, .. } => *anchor,
        }
    }

    /// Expand shorthand patterns into full regex patterns
    ///
    /// Supported shorthands:
    /// - `contains_word:word` -> `\bword\b`
    /// - `not:pattern` -> negative match (handled in matching logic)
    pub fn expand_pattern(pattern: &str) -> String {
        // Handle 'contains_word:' shorthand
        if let Some(word) = pattern.strip_prefix("contains_word:") {
            return format!(r"\b{}\b", regex::escape(word.trim()));
        }

        // No shorthand - return as-is
        pattern.to_string()
    }

    /// Apply anchor to pattern
    pub fn apply_anchor(pattern: &str, anchor: Option<Anchor>) -> String {
        match anchor {
            Some(Anchor::Start) => format!("^{}", pattern),
            Some(Anchor::End) => format!("{}$", pattern),
            Some(Anchor::Contains) | None => pattern.to_string(),
        }
    }
}
```
  </action>
  <verify>cargo check --package rulez</verify>
  <done>PromptMatch enum with all helper methods compiles</done>
</task>

<task type="auto">
  <name>Task 3: Add prompt_match to Matchers and prompt to Event</name>
  <files>rulez/src/models.rs</files>
  <action>
1. Add `prompt_match` field to the Matchers struct (after command_match field, around line 276):

```rust
    /// Prompt text pattern matching for UserPromptSubmit events
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prompt_match: Option<PromptMatch>,
```

2. Add `prompt` field to the Event struct (after tool_use_id field, around line 1484):

```rust
    /// User prompt text (sent by Claude Code on UserPromptSubmit events)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prompt: Option<String>,
```

3. Update ALL test functions that create Matchers structs to include `prompt_match: None`. Search for "Matchers {" and add the field to each occurrence.

4. Update ALL test functions that create Event structs to include `prompt: None`. Search for "Event {" and add the field to each occurrence.
  </action>
  <verify>cargo test --package rulez -- --test-threads=1</verify>
  <done>Matchers has prompt_match field, Event has prompt field, all existing tests pass</done>
</task>

</tasks>

<verification>
1. `cargo check --package rulez` passes
2. `cargo test --package rulez` passes (all 245+ tests)
3. YAML parsing test:
   ```rust
   let yaml = r#"prompt_match: ["delete", "drop"]"#;
   let matchers: Matchers = serde_yaml::from_str(yaml).unwrap();
   assert!(matchers.prompt_match.is_some());
   ```
</verification>

<success_criteria>
- PromptMatch enum deserializes from both simple array and complex object syntax
- MatchMode defaults to Any, case_insensitive defaults to false
- All existing 245+ tests continue to pass
- No breaking changes to existing API
</success_criteria>

<output>
After completion, create `.planning/phases/04-prompt-matching/04-01-SUMMARY.md`
</output>
