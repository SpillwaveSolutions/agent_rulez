---
phase: 02-command-based-context
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rulez/src/models.rs
  - rulez/src/hooks.rs
  - rulez/src/config.rs
autonomous: true

must_haves:
  truths:
    - "inject_command field parses from YAML configuration"
    - "Command output is captured and injected as context"
    - "Command failures log warning and continue (fail-open)"
    - "Timeout prevents hanging on slow commands"
  artifacts:
    - path: "rulez/src/models.rs"
      provides: "inject_command field in Actions struct"
      contains: "inject_command"
    - path: "rulez/src/hooks.rs"
      provides: "execute_inject_command function and integration"
      contains: "execute_inject_command"
  key_links:
    - from: "rulez/src/hooks.rs"
      to: "rulez/src/models.rs"
      via: "Actions.inject_command field access"
      pattern: "actions\\.inject_command"
---

<objective>
Add inject_command field to Actions struct and implement command execution with stdout capture.

Purpose: Enable dynamic context generation by running shell commands and injecting their output.
Output: Working inject_command action that executes commands and injects stdout as context.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-command-based-context/02-RESEARCH.md
@.planning/phases/01-inline-content-injection/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add inject_command field to Actions struct</name>
  <files>rulez/src/models.rs, rulez/src/config.rs</files>
  <action>
Add `inject_command: Option<String>` field to the Actions struct in models.rs:

1. In `models.rs`, add to Actions struct (after inject_inline):
```rust
/// Shell command to execute and inject stdout as context
#[serde(skip_serializing_if = "Option::is_none")]
pub inject_command: Option<String>,
```

2. Update ALL test Actions instantiations in models.rs to include `inject_command: None`
   - Search for `Actions {` in the tests and add the field

3. Update ALL test Actions instantiations in config.rs to include `inject_command: None`
   - Same pattern as models.rs tests

4. Add YAML parsing test for inject_command in models.rs:
```rust
#[test]
fn test_inject_command_yaml() {
    let yaml = r#"
inject_command: "git branch --show-current"
"#;
    let actions: Actions = serde_yaml::from_str(yaml).unwrap();
    assert!(actions.inject_command.is_some());
    assert_eq!(actions.inject_command.unwrap(), "git branch --show-current");
}
```

Follow the exact pattern used for inject_inline in Phase 1.
  </action>
  <verify>
```bash
cd /Users/richardhightower/clients/spillwave/src/rulez_plugin/rulez && cargo test --lib 2>&1 | head -50
```
All unit tests pass including the new inject_command YAML parsing test.
  </verify>
  <done>
inject_command field added to Actions struct with serde attributes, all existing tests updated, new YAML parsing test passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement execute_inject_command function</name>
  <files>rulez/src/hooks.rs</files>
  <action>
Add the execute_inject_command async function in hooks.rs, following the pattern from execute_validator_script but simplified:

1. Add the function BEFORE execute_rule_actions (around line 336):

```rust
/// Execute a shell command and capture stdout for context injection
///
/// Unlike validators:
/// - No stdin input needed
/// - Raw text output (not JSON)
/// - Fail-open: command failures log warning but don't block
async fn execute_inject_command(
    command_str: &str,
    rule: &Rule,
    config: &Config,
) -> Option<String> {
    let timeout_secs = rule
        .metadata
        .as_ref()
        .map(|m| m.timeout)
        .unwrap_or(config.settings.script_timeout);

    // Use shell to execute (enables pipes, redirects, etc.)
    let mut command = Command::new("sh");
    command.arg("-c");
    command.arg(command_str);
    command.stdout(std::process::Stdio::piped());
    command.stderr(std::process::Stdio::piped());
    // No stdin - don't pipe it (causes hangs)

    let child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            tracing::warn!(
                "Failed to spawn inject_command '{}' for rule '{}': {}",
                command_str, rule.name, e
            );
            return None;
        }
    };

    let output = match timeout(
        Duration::from_secs(timeout_secs as u64),
        child.wait_with_output(),
    ).await {
        Ok(Ok(output)) => output,
        Ok(Err(e)) => {
            tracing::warn!(
                "inject_command '{}' for rule '{}' failed: {}",
                command_str, rule.name, e
            );
            return None;
        }
        Err(_) => {
            tracing::warn!(
                "inject_command '{}' for rule '{}' timed out after {}s",
                command_str, rule.name, timeout_secs
            );
            return None;
        }
    };

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        tracing::warn!(
            "inject_command '{}' for rule '{}' failed with exit code {}: {}",
            command_str,
            rule.name,
            output.status.code().unwrap_or(-1),
            stderr.trim()
        );
        return None;
    }

    let stdout = String::from_utf8_lossy(&output.stdout).to_string();
    if stdout.trim().is_empty() {
        return None; // No content to inject
    }

    Some(stdout)
}
```

2. Integrate into execute_rule_actions function - add AFTER inject_inline handling (around line 374) and BEFORE inject file handling:

```rust
    // Handle command-based injection (after inject_inline, before inject file)
    if let Some(ref command_str) = actions.inject_command {
        if let Some(output) = execute_inject_command(command_str, rule, config).await {
            return Ok(Response::inject(output));
        }
        // Command failed or produced no output - continue to next action
    }
```

3. Add SAME handling to execute_rule_actions_warn_mode function - add after inject_inline handling (around line 604):

```rust
    // Handle command-based injection (after inject_inline, before inject file)
    if let Some(ref command_str) = actions.inject_command {
        if let Some(output) = execute_inject_command(command_str, rule, config).await {
            return Ok(Response::inject(output));
        }
        // Command failed or produced no output - continue to next action
    }
```

Execution order is now: inject_inline > inject_command > inject > run
  </action>
  <verify>
```bash
cd /Users/richardhightower/clients/spillwave/src/rulez_plugin/rulez && cargo build 2>&1 | tail -20
```
Build succeeds with no errors.
  </verify>
  <done>
execute_inject_command function implemented with timeout, error handling, and integrated into both execute_rule_actions and execute_rule_actions_warn_mode.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update test struct instantiations in hooks.rs</name>
  <files>rulez/src/hooks.rs</files>
  <action>
Update ALL Actions struct instantiations in hooks.rs tests to include the new inject_command field:

1. Search for `Actions {` in the test module at the bottom of hooks.rs
2. Add `inject_command: None,` to each Actions instantiation

Expected locations (around lines 800-1050):
- test_rule_matching
- test_rule_non_matching
- test_rule_effective_mode_defaults_to_enforce
- test_rule_effective_mode_explicit_audit
- create_rule_with_mode helper function

Pattern to apply:
```rust
actions: Actions {
    block: Some(true),
    inject: None,
    inject_inline: None,
    inject_command: None,  // ADD THIS LINE
    run: None,
    block_if_match: None,
},
```
  </action>
  <verify>
```bash
cd /Users/richardhightower/clients/spillwave/src/rulez_plugin/rulez && cargo test 2>&1 | tail -30
```
All 73+ tests pass.
  </verify>
  <done>
All test Actions struct instantiations in hooks.rs updated with inject_command: None.
  </done>
</task>

</tasks>

<verification>
Run full test suite to verify no regressions:
```bash
cd /Users/richardhightower/clients/spillwave/src/rulez_plugin/rulez && cargo test 2>&1
```

Expected: All tests pass (73+ tests), build succeeds, no warnings about unused fields.
</verification>

<success_criteria>
- inject_command field parses from YAML
- execute_inject_command function compiles and is integrated
- All existing tests pass with new field
- Build produces no warnings
</success_criteria>

<output>
After completion, create `.planning/phases/02-command-based-context/02-01-SUMMARY.md`
</output>
